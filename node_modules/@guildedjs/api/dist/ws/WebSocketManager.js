"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketManager = void 0;
/* eslint-disable @typescript-eslint/no-base-to-string */
const node_events_1 = require("node:events");
const ws_1 = __importDefault(require("ws"));
const api_typings_1 = require("../generated/api-typings");
const Heartbeater_1 = __importDefault(require("./Heartbeater"));
class WebSocketManager {
    constructor(options) {
        var _a;
        this.options = options;
        /**
         * The version of the websocket to connect to.
         */
        this.version = (_a = this.options.version) !== null && _a !== void 0 ? _a : 1;
        /**
         * Token used to authenticate requests.
         */
        this.token = this.options.token;
        /**
         * The websocket connected to guilded.
         */
        this.socket = null;
        /**
         * Whether or not this connection is connected and heartbeating.
         */
        this.isAlive = false;
        /**
         * The amount of milliseconds the websocket took to respond to the last ping request. This will be zero before the first heartbeat
         */
        this.ping = 0;
        /**
         * The timestamp in milliseconds of the last ping request.
         */
        this.lastPingedAt = 0;
        /**
         * The last message id received. Used in the event of resuming connections.
         */
        this.lastMessageId = null;
        /**
         * The date since the last initial connection was established.
         */
        this.connectedAt = null;
        /**
         * Emitter in charge of emitting ws gateway related events
         */
        this.emitter = new node_events_1.EventEmitter();
        /**
         * Count of how many times a reconnect has been attempted
         */
        this.reconnectAttemptAmount = 0;
        /**
         * Heartbeating helper
         */
        this.heartbeater = null;
    }
    /**
     * The url that will be used to connect. Prioritizes proxy url and if not available uses the default base url for guidled.
     */
    get wsURL() {
        var _a;
        return (_a = this.options.proxyURL) !== null && _a !== void 0 ? _a : `wss://www.guilded.gg/websocket/v${this.version}`;
    }
    get reconnectAttemptExceeded() {
        var _a;
        return this.reconnectAttemptAmount >= ((_a = this.options.reconnectAttemptLimit) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY);
    }
    get shouldReplayMissedEvents() {
        return this.options.replayMissedEvents !== false;
    }
    get shouldRequestMissedEvents() {
        return this.shouldReplayMissedEvents && this.lastMessageId !== null;
    }
    connect() {
        this._debug(`Connecting to Guilded WS Gateway at url ${this.wsURL}.`);
        const headers = {
            Authorization: `Bearer ${this.token}`,
        };
        if (this.shouldRequestMissedEvents) {
            this._debug(`Requesting missed events from last message ${this.lastMessageId}.`);
            if (this.lastMessageId) {
                headers["guilded-last-message-id"] = this.lastMessageId;
            }
        }
        try {
            this.socket = new ws_1.default(this.wsURL, {
                headers,
            });
            this._debug("Socket created.");
        }
        catch (error) {
            this._debug(`Error creating socket ${error.message}.`);
            if (!this.shouldRequestMissedEvents && this.lastMessageId)
                throw error;
            this.lastMessageId = null;
            if (error instanceof Error) {
                this.emitter.emit("error", "Error connecting to socket", error);
            }
            this._handleDisconnect({ blockReconnects: false });
            return;
        }
        this.socket.on("open", this.onSocketOpen.bind(this));
        this.socket.on("ping", this.onSocketPing.bind(this));
        this.socket.on("pong", this.onSocketPong.bind(this));
        this.socket.on("message", (data) => {
            this.emitter.emit("raw", data);
            this.onSocketMessage(data.toString());
        });
        this.socket.on("error", (err) => {
            this._debug(`Error received from WS. ${err.message}`);
            this.emitter.emit("exit", "Gateway connection  closed due to error.");
            this._handleDisconnect({ blockReconnects: true });
        });
        this.socket.on("close", (code, reason) => {
            this.emitter.emit("exit", "Gateway connection closed.");
            this._handleDisconnect({ blockReconnects: false });
        });
    }
    destroy() {
        var _a;
        this._debug("Destroying websocket connection.");
        if (!this.socket) {
            throw new Error("There is no active connection to destroy.");
        }
        (_a = this.heartbeater) === null || _a === void 0 ? void 0 : _a.destroy();
        this.heartbeater = null;
        this.socket.removeAllListeners();
        if (!this.socket.CLOSED && !this.socket.CLOSING)
            this.socket.close();
        this.socket = null;
        this.isAlive = false;
    }
    _handleDisconnect(opts) {
        var _a;
        this._debug(`Received request to disconnect.`);
        this.destroy();
        this._debug(`Checking if should reconnect. 
      Reconnect allowed: ${this.options.autoConnectOnErr}. 
      Reconnect attempt ${this.reconnectAttemptAmount}. 
      Reconnect attempt limit ${this.options.reconnectAttemptLimit}.`);
        if ((!opts.blockReconnects && ((_a = this.options.autoConnectOnErr) !== null && _a !== void 0 ? _a : true)) || !this.reconnectAttemptExceeded) {
            this._debug("Reconnecting.");
            this.reconnectAttemptAmount++;
            this.connect();
        }
    }
    _debug(str) {
        return this.emitter.emit("debug", `[DEBUG] ${str}`);
    }
    onSocketMessage(packet) {
        let EVENT_NAME;
        let EVENT_DATA;
        try {
            const data = JSON.parse(packet);
            EVENT_NAME = data.t;
            EVENT_DATA = data;
        }
        catch (error) {
            this.emitter.emit("error", "ERROR PARSING WS EVENT", error, packet);
            return void 0;
        }
        this._debug(`Received event ${EVENT_NAME}. ${packet}}`);
        // SAVE THE ID IF AVAILABLE. USED FOR RESUMING CONNECTIONS.
        if (EVENT_DATA.s)
            this.lastMessageId = EVENT_DATA.s;
        switch (EVENT_DATA.op) {
            // Normal event based packets
            case api_typings_1.WSOpCodes.SUCCESS: {
                this.emitter.emit("gatewayEvent", EVENT_NAME, EVENT_DATA);
                break;
            }
            // Auto handled by ws lib
            case api_typings_1.WSOpCodes.WELCOME: {
                this._debug("Received welcome packet. Setting up heartbeat.");
                this.heartbeater = new Heartbeater_1.default(this, EVENT_DATA.d.heartbeatIntervalMs);
                this.emitter.emit("ready", EVENT_DATA.d.user);
                break;
            }
            case api_typings_1.WSOpCodes.RESUME: {
                this._debug("Received resume packet.");
                this.lastMessageId = null;
                break;
            }
            case api_typings_1.WSOpCodes.ERROR: {
                this._debug("Received error packet.");
                this.emitter.emit("error", "Error received from WS", new Error(EVENT_DATA.d.message));
                this.lastMessageId = null;
                this._handleDisconnect({
                    blockReconnects: false,
                });
                break;
            }
            default: {
                this._debug("Received unknown opcode.");
                this.emitter.emit("unknown", "unknown opcode", packet);
                break;
            }
        }
    }
    onSocketOpen() {
        this._debug("Socket has been successfully opened and is ready to receive data.");
        this.isAlive = true;
        this.connectedAt = new Date();
    }
    onSocketPing() {
        this._debug(`Ping request from Guilded received. Responding with a pong.`);
        this.socket.pong();
    }
    onSocketPong() {
        this.ping = Date.now() - this.lastPingedAt;
        this._debug(`Pong response from Guilded received. Latency: ${this.ping}ms.`);
    }
}
exports.WebSocketManager = WebSocketManager;
//# sourceMappingURL=WebSocketManager.js.map