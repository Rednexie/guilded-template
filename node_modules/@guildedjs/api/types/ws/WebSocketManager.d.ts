import type TypedEmitter from "typed-emitter";
import WebSocket from "ws";
import type { SkeletonWSPayload, WSEvent, WSPayload } from "../generated/api-typings";
import Heartbeater from "./Heartbeater";
export declare class WebSocketManager {
    readonly options: WebSocketOptions;
    /**
     * The version of the websocket to connect to.
     */
    version: 1;
    /**
     * Token used to authenticate requests.
     */
    token: string;
    /**
     * The websocket connected to guilded.
     */
    socket: WebSocket | null;
    /**
     * Whether or not this connection is connected and heartbeating.
     */
    isAlive: boolean;
    /**
     * The amount of milliseconds the websocket took to respond to the last ping request. This will be zero before the first heartbeat
     */
    ping: number;
    /**
     * The timestamp in milliseconds of the last ping request.
     */
    lastPingedAt: number;
    /**
     * The last message id received. Used in the event of resuming connections.
     */
    lastMessageId: string | null;
    /**
     * The date since the last initial connection was established.
     */
    connectedAt: Date | null;
    /**
     * Emitter in charge of emitting ws gateway related events
     */
    emitter: TypedEmitter<WebsocketManagerEvents>;
    /**
     * Count of how many times a reconnect has been attempted
     */
    reconnectAttemptAmount: number;
    /**
     * Heartbeating helper
     */
    heartbeater: Heartbeater | null;
    constructor(options: WebSocketOptions);
    /**
     * The url that will be used to connect. Prioritizes proxy url and if not available uses the default base url for guidled.
     */
    get wsURL(): string;
    get reconnectAttemptExceeded(): boolean;
    get shouldReplayMissedEvents(): boolean;
    get shouldRequestMissedEvents(): boolean;
    connect(): void;
    destroy(): void;
    _handleDisconnect(opts: {
        blockReconnects: boolean;
    }): void;
    _debug(str: any): boolean;
    private onSocketMessage;
    private onSocketOpen;
    private onSocketPing;
    private onSocketPong;
}
export type WebSocketOptions = {
    /**
     * Whether to try to re-establish connection on error
     */
    autoConnectOnErr?: boolean;
    /**
     * The base url that the websocket will connect to.
     */
    proxyURL?: string;
    /**
     * Limit of how many times a reconnection should be attempted
     */
    reconnectAttemptLimit?: number;
    /**
     * Whether the manager should request missed events on reconnect
     */
    replayMissedEvents?: boolean;
    /**
     * The bot's token.
     */
    token: string;
    /**
     * The version of the websocket to connect to.
     */
    version?: 1;
};
export type WebsocketManagerEvents = {
    debug(data: any): unknown;
    error(reason: string, err: Error | null, data?: any): unknown;
    exit(info: string): unknown;
    gatewayEvent(event: keyof WSEvent, data: SkeletonWSPayload): unknown;
    raw(data: any): unknown;
    ready(user: WSPayload<"_WelcomeMessage">["user"] & {
        createdBy: string;
        botId: string;
    }): unknown;
    reconnect(): unknown;
    unknown(reason: string, data: any): unknown;
};
//# sourceMappingURL=WebSocketManager.d.ts.map