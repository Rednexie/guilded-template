import { Collection } from "@discordjs/collection";
import type { ChatService } from "@guildedjs/api";
import type { CollectorOptions, CollectorReturnValue } from "../../structures";
import { Message } from "../../structures/Message";
import type { MessageContent, OptionQuery } from "../../typings";
import { CacheableStructManager } from "./CacheableStructManager";
/**
 * Manager for handling caching and interactions for Messages
 */
export declare class GlobalMessageManager extends CacheableStructManager<string, Message> {
    /**
     * Whether or not messages should be cached.
     */
    get shouldCacheMessage(): boolean;
    /**
     * Fetches multiple messages from a channel.
     *
     * @param channelId The ID of the channel to fetch messages from.
     * @param options Additional options for the fetch.
     * @returns A promise that resolves with a collection of messages.
     */
    fetchMany(channelId: string, options: Omit<OptionQuery<ChatService["channelMessageReadMany"]>, "channelId">): Promise<Collection<string, Message>>;
    /**
     * Fetches a message from a channel.
     *
     * @param channelId The ID of the channel to fetch the message from.
     * @param messageId The ID of the message to fetch.
     * @param force Whether or not to force the fetch.
     * @returns A promise that resolves with the requested message.
     */
    fetch(channelId: string, messageId: string, force?: boolean): Promise<Message>;
    /**
     * Sends a message to a channel.
     *
     * @param channelId The ID of the channel to send the message to.
     * @param content The content of the message.
     * @returns A promise that resolves with the created message.
     * @example
     * let replyObj = {
     *  content: 'This is text, supports **markdown**.',
     *  embeds: [{
     *    title: 'This is an embed title!',
     *    description: 'A description may go here'
     *  }]
     * };
     * await message.client.messages.send(message.channelId, replyObj)
     */
    send(channelId: string, content: MessageContent): Promise<Message>;
    /**
     * Adds a reaction to a message.
     *
     * @param channelId The ID of the channel containing the message.
     * @param contentId The ID of the message to add a reaction to.
     * @param emoteId The ID of the emote to add as a reaction.
     * @returns A promise that resolves to nothing when the reaction is added.
     */
    addReaction(channelId: string, contentId: string, emoteId: number): Promise<void>;
    /**
     * Deletes either a whole reaction emote from a message or a specific user's if a userId is provided.
     *
     * @param channelId The ID of the channel containing the message.
     * @param contentId The ID of the message to delete the reaction from.
     * @param emoteId The ID of the emote to delete as a reaction.
     * @returns A promise that resolves to nothing when the reaction is deleted.
     */
    deleteReaction(channelId: string, contentId: string, emoteId: number, userId?: string): Promise<void>;
    /**
     * Updates a message in a channel.
     *
     * @param channelId The ID of the channel containing the message.
     * @param messageId The ID of the message to update.
     * @param content The new content of the message.
     * @returns A promise that resolves with the updated message.
     */
    update(channelId: string, messageId: string, content: MessageContent): Promise<Message>;
    /** Delete a channel message. */
    delete(channelId: string, messageId: string): Promise<void>;
    awaitMessages(channelId: string, options: CollectorOptions<Message>): Promise<CollectorReturnValue<Message>>;
}
//# sourceMappingURL=MessageManager.d.ts.map