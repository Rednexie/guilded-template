import type { ChannelsService, ServerChannelPayload } from "@guildedjs/api";
import { Channel, ChatChannel, DocChannel, ForumChannel, ListChannel } from "../../structures";
import type { OptionBody } from "../../typings";
import { CacheableStructManager } from "./CacheableStructManager";
/**
 * Manages channels on the global scope. This can hold channels of any type, with all of them extending Channel.
 * You will likely need to cast the returned values from cache or fetches
 *
 * @extends CacheableStructManager
 */
export declare class GlobalChannelManager extends CacheableStructManager<string, Channel> {
    /** Determine whether a channel should be cached or not */
    get shouldCacheChannel(): boolean;
    /**
     * Create a new channel
     *
     * @param options Channel creation options
     * @returns Promise that resolves with the newly created channel
     */
    create(options: OptionBody<ChannelsService["channelCreate"]>): Promise<Channel>;
    /**
     * Fetch a channel by ID
     * Notice: if you're using TypeScript, you will need to upcast to your desired channel type.
     *
     * @param channelId ID of the channel to fetch
     * @param force Whether to force a fetch from the API
     * @returns Promise that resolves with the fetched channel
     */
    fetch(channelId: string, force?: boolean): Promise<Channel>;
    /**
     * Update a channel by ID
     *
     * @param channelId ID of the channel to update
     * @param options Channel update options
     * @returns Promise that resolves with the updated channel
     */
    update(channelId: string, options: OptionBody<ChannelsService["channelUpdate"]>): Promise<Channel>;
    /**
     * Delete a channel by ID
     *
     * @param channelId ID of the channel to delete
     * @returns Promise that resolves with the deleted channel, or null if not cached.
     */
    delete(channelId: string): Promise<Channel | null>;
    /**
     * Archive a channel by ID
     *
     * @param channelId ID of the channel to archive
     * @returns Promise that resolves with the archived channel or null if not cached
     */
    archive(channelId: string): Promise<Channel | null>;
    /**
     * Unarchive a channel by ID
     *
     * @param channelId ID of the channel to unarchive
     * @returns Promise that resolves with the unarchived channel or null if not cached
     */
    unarchive(channelId: string): Promise<Channel | null>;
}
/**
 * Transforms the string APIChannelType to its corresponding channel class
 *
 * @param str String representing the channel type
 * @returns Channel class for the given channel type
 */
export declare const transformTypeToChannel: (str: ServerChannelPayload["type"]) => (typeof typeToChannel)[keyof typeof typeToChannel];
/** Mapping between the string APIChannelType and the corresponding channel class */
export declare const typeToChannel: {
    chat: typeof ChatChannel;
    forums: typeof ForumChannel;
    docs: typeof DocChannel;
    list: typeof ListChannel;
};
//# sourceMappingURL=ChannelManager.d.ts.map