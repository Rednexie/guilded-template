import { Collection } from "@discordjs/collection";
import type { CalendarEventPayload, MentionsPayload, CalendarEventRsvpPayload } from "@guildedjs/api";
import { Base } from "./Base";
import type { Client } from "./Client";
import type { User } from "./User";
/**
 * Represents a calendar event on Guilded
 */
export declare class CalendarEvent extends Base<CalendarEventPayload, number> {
    /** The ID of the calendar event (min 1) */
    readonly id: number;
    /** The ID of the server */
    readonly serverId: string;
    /** The ID of the channel */
    readonly channelId: string;
    /** The name of the event (min length 1; max length 60) */
    name: string;
    /**  The description of the event (min length 1; max length 8000) */
    description?: string | null;
    /** The location of the event (min length 1; max length 8000) */
    location?: string | null;
    /** A URL to associate with the event */
    url?: string | null;
    /** The color of the event when viewing in the calendar (min 0; max 16777215) */
    color?: number | null;
    /** The ISO 8601 timestamp that the event starts at */
    startsAt: string;
    /** The duration of the event in minutes (min 1) */
    duration?: number | null;
    /** Whether this event is private or not */
    isPrivate?: boolean;
    /** The mentions in this calendar event */
    mentions?: MentionsPayload;
    /** The cancellations for this event */
    cancellation?: CalendarEventPayload["cancellation"];
    /** The number of rsvps to allow before waitlisting rsvps (min 1) */
    rsvpLimit?: number | null;
    /** A collection of cached rsvps for this calendar event */
    rsvps: Collection<string, CalendarEventRsvp>;
    /** The role IDs to restrict the event to (min items 1; must have unique items true) */
    roleIds?: number[] | null;
    /** The ID of the calendar event series. Only shows if the event is repeating */
    seriesId?: string | null;
    /** Whether this event is repeating */
    repeats?: boolean | null;
    /** Whether this event lasts all day */
    isAllDay?: boolean | null;
    /** When rsvpLimit is set, users from the waitlist will be added as space becomes available in the event */
    autofillWaitlist?: boolean | null;
    /** The ISO 8601 timestamp that the event was created at */
    readonly _createdAt: number;
    /** The ID of the user who created this event */
    readonly createdBy: string;
    constructor(client: Client, data: CalendarEventPayload);
    /**
     * Get the author of this calendar event
     *
     * @returns The author of this calendar event or null if the author is not cached
     */
    get author(): User | null;
    /**
     * Get the date this calendar event was created
     *
     * @returns The date this calendar event was created
     */
    get createdAt(): Date;
    _update(data: Partial<CalendarEventPayload>): this;
}
/**
 * Represents a calendar event RSVP
 */
export declare class CalendarEventRsvp extends Base<CalendarEventRsvpPayload, string> {
    /** The ID of the calendar event (min 1) */
    readonly calendarEventId: number;
    /** The ID of the channel */
    readonly channelId: string;
    /** The ID of the server */
    readonly serverId: string;
    /** The ID of the user */
    readonly userId: string;
    /** The status of the rsvp ("going", "maybe", "declined", "invited", "waitlisted", or "not responded") */
    status: string;
    /** The ID of the user who created this rsvp */
    readonly createdBy: string;
    /** The ISO 8601 timestamp that the rsvp was created at */
    readonly _createdAt: number;
    /** The ID of the user who updated this rsvp */
    updatedBy?: string | null;
    /** The ISO 8601 timestamp that the rsvp was updated at, if relevant */
    updatedAt?: string | null;
    constructor(client: Client, data: CalendarEventRsvpPayload);
    get author(): User | null;
    get createdAt(): Date;
    _update(data: Partial<CalendarEventRsvpPayload>): this;
}
//# sourceMappingURL=CalendarEvent.d.ts.map