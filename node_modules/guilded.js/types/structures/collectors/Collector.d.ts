/// <reference types="node" />
import { Collection } from "@discordjs/collection";
import type { MaybePromise } from "../../typings";
import type { Client } from "../Client";
/**
 * A collector is just a wrapper over a set of events for collecting a structure.
 * Commonly used for things like Message or MessageReaction collecting, collectors allow you
 * to have your code wait until further input from a user.
 */
export declare abstract class Collector<T extends CollectableStructure> {
    readonly client: Client;
    options: Partial<CollectorOptions<T>>;
    /** Collection of successfully collected entries */
    readonly entries: Collection<T["id"], T>;
    /** Whether the collector is actively collecting elements */
    isActive: boolean;
    /** Method to resolve the promise this collector has when instantiated */
    protected resolve: ((value: CollectorReturnValue<T>) => void) | null;
    /** Timeout for max time */
    protected maxTimeout: NodeJS.Timeout | null;
    /** Bound function for item receiving */
    protected boundItemReceiver: (entry: T) => Promise<boolean>;
    constructor(client: Client, options: Partial<CollectorOptions<T>>);
    /**
     * Start the collector
     *
     * @returns A promise that resolves with a `CollectorReturnValue` object
     */
    start(): Promise<CollectorReturnValue<T>>;
    /**
     * Receives an item
     *
     * @param entry - The item received
     * @returns Whether the item passes the filter function or not
     */
    itemReceived(entry: T): Promise<boolean>;
    /**
     * Increment the max number of event listeners for the client
     *
     * @returns The new max number of event listeners for the client
     */
    protected incrementMaxEventListeners(): number;
    /**
     * Decrement the max number of event listeners for the client
     *
     * @returns The new max number of event listeners for the client
     */
    protected decrementMaxEventListeners(): number;
    /**
     * Hook events to the collector
     */
    abstract hookEvents(): void;
    /**
     * Clean up the collector
     */
    abstract _cleanup(): void;
}
/**
 * Reasons why a collector has ended
 */
export declare enum CollectorEndReasons {
    MAX = "MAX_AMOUNT",
    TIME = "TIME_EXPIRED"
}
/**
 * The value returned by a collector when it ends
 */
export type CollectorReturnValue<T extends CollectableStructure> = {
    reason: CollectorEndReasons;
    entries: Collection<T["id"], T>;
};
/**
 * The base structure of objects that can be collected by a collector
 */
type CollectableStructure = {
    id: string;
};
/** options for constructing a collector */
export type CollectorOptions<T> = {
    /** a function that determines whether an entry is collected or not */
    filter?(item: T): MaybePromise<boolean>;
    /** the max amount of time this collector run for before exiting (ms) */
    timeLimit: number;
    /** the max amount of entries allowed to be collected */
    max?: number;
};
export {};
//# sourceMappingURL=Collector.d.ts.map