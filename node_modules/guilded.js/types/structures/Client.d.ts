import type { Collection } from "@discordjs/collection";
import { RestManager, WebSocketManager } from "@guildedjs/api";
import type { SkeletonWSPayload } from "@guildedjs/api";
import type TypedEmitter from "typed-emitter";
import type { CacheStructure } from "../cache";
import { ClientGatewayHandler } from "../gateway/ClientGatewayHandler";
import { GlobalCalendarManager } from "../managers/global/CalendarManager";
import { GlobalCategoryManager } from "../managers/global/CategoryManager";
import { GlobalChannelManager } from "../managers/global/ChannelManager";
import { GlobalDocManager } from "../managers/global/DocManager";
import { GlobalForumTopicManager } from "../managers/global/ForumManager";
import { GlobalGroupManager } from "../managers/global/GroupManager";
import { GlobalGuildBanManager } from "../managers/global/GuildBanManager";
import { GlobalListItemManager } from "../managers/global/ListManager";
import { GlobalMemberManager } from "../managers/global/MemberManager";
import { GlobalMessageManager } from "../managers/global/MessageManager";
import { GlobalReactionManager } from "../managers/global/ReactionManager";
import { GlobalRoleManager } from "../managers/global/RoleManager";
import { GlobalServerManager } from "../managers/global/ServerManager";
import { GlobalSubscriptionManager } from "../managers/global/SubscriptionManager";
import { GlobalUserManager } from "../managers/global/UserManager";
import { GlobalWebhookManager } from "../managers/global/WebhookManager";
import type { ClientEvents } from "../typings";
import type { Server } from "./Server";
import { ClientUser } from "./User";
declare const Client_base: new () => TypedEmitter<ClientEvents>;
/**
 * The main class for interacting with the api.
 *
 * @template ClientEvents The custom events for the client.
 */
export declare class Client extends Client_base {
    options: ClientOptions;
    /**
     * The time in milliseconds since the Client connected.
     */
    readyTimestamp: number | null;
    /**
     * The manager for the bot to make requests to the REST api.
     */
    rest: RestManager;
    /**
     * The websocket connection.
     */
    ws: WebSocketManager;
    /**
     * The gateway events will be processed by this manager.
     */
    gatewayHandler: ClientGatewayHandler;
    /**
     * A manager for channels, used to manage and interact with channels.
     */
    channels: GlobalChannelManager;
    /**
     * A manager for docs, used to manage and interact with docs.
     */
    docs: GlobalDocManager;
    /**
     * A manager for forum topics, used to manage and interact with forum topics.
     */
    topics: GlobalForumTopicManager;
    /**
     * A manager for groups, used to manage and interact with groups.
     */
    groups: GlobalGroupManager;
    /**
     * A manager for list items, used to manage and interact with list items.
     */
    lists: GlobalListItemManager;
    /**
     * A manager for members, used to manage and interact with members.
     */
    members: GlobalMemberManager;
    /**
     * A manager for messages, used to manage and interact with messages.
     */
    messages: GlobalMessageManager;
    /**
     * A manager for roles, used to manage and interact with roles.
     */
    roles: GlobalRoleManager;
    /**
     * A manager for users, used to manage and interact with users.
     */
    users: GlobalUserManager;
    /**
     * A manager for guild bans, used to manage and interact with bans.
     */
    bans: GlobalGuildBanManager;
    /**
     * A manager for webhooks, used to manage and interact with webhooks.
     */
    webhooks: GlobalWebhookManager;
    /**
     * A manager for servers, used to manage and interact with servers.
     */
    servers: GlobalServerManager;
    /**
     * A manager for reactions, used to manage and interact with reactions.
     */
    reactions: GlobalReactionManager;
    /**
     * A manager for calendars, used to manage and interact with calendars.
     */
    calendars: GlobalCalendarManager;
    /**
     * A manager for categories, used to manage and interact with categories.
     */
    categories: GlobalCategoryManager;
    /**
     * A manager for server subscriptions, used to manage and interact with server subscriptions.
     */
    subscriptions: GlobalSubscriptionManager;
    /**
     * The user belonging to this bot.
     */
    user: ClientUser | null;
    /**
     * @param options The options for the client.
     * @throws {Error} Must provide options in client constructor in the form of an object.
     * @throws {Error} No token provided.
     */
    constructor(options: ClientOptions);
    /**
     * The amount of time the bot has been online in milliseconds.
     */
    get uptime(): number;
    /**
     * The bot's token.
     */
    get token(): string;
    /**
     * Connects the bot to the api.
     *
     * @param [opts] The options for connecting to the api.
     * @param [opts.fresh] Whether this should create a new WebSocketManager instance.
     * @example
     * let client = new Guilded.Client({ token: process.env.GUILDED_TOKEN });
     * client.on('ready', () => console.log('Logged in!'));
     * client.login();
     */
    login(opts?: {
        fresh?: boolean;
    }): void;
    /**
     * Disconnects the bot.
     *
     * @throws {Error} There is no active connection to disconnect.
     */
    disconnect(): void;
    /**
     * Fetches the logged in client's servers.
     *
     * @returns The logged in client's servers.
     */
    fetchServers(): Promise<Collection<string, Server>>;
    /**
     * Set current logged in client's status
     *
     * @param options The options for setting the status.
     * @param options.content The content of the status.
     * @param options.emoteId The id of the emote to use for the status.
     * @param options.expiresAt The time the status should expire.
     */
    setStatus(options: {
        content?: string;
        emoteId: number;
        expiresAt?: Date | number | string;
    }): Promise<void>;
    /**
     * Clear current logged in client's status
     */
    clearStatus(): Promise<void>;
}
/**
 * Options for constructing the client.
 */
export type ClientOptions = {
    /**
     * The bot's token.
     *
     * @remarks The token is required to authenticate with the Guilded API.
     */
    token: string;
    /**
     * The RestManager options.
     */
    rest?: {
        /**
         * The version of the API to be used for making requests. By default, this will use the latest version that the library supports.
         *
         * @default 1
         * @remarks You can set the API version to 1 if you want to use the stable API.
         */
        version?: 1;
        /**
         * The base url of the API you want to send requests to. By default, this will send it to guilded's rest API.
         * This is meant for big bot developers who want to use a proxy rest system.
         *
         * @remarks If you want to use a custom API url, you can set this property to your custom url.
         */
        proxyURL?: string;
    };
    /**
     * Gateway handling options
     */
    gateway?: {
        /**
         * A boolean returning function that dictates whether an event is discarded
         */
        discardEvent?(event: string, data: SkeletonWSPayload): boolean;
    };
    /**
     * The cache options for the client.
     */
    cache?: {
        /**
         * The function to create a new instance of CacheStructure.
         *
         * @remarks You can use this to provide your own implementation of CacheStructure, which will be used to cache data in the client in a future update.
         */
        structureBuilder?<K, V>(): CacheStructure<K, V>;
        /**
         * Whether to fetch the author of a message when it is created and cache it.
         *
         * @default false
         */
        fetchMessageAuthorOnCreate?: boolean;
        /**
         * Whether to remove a member from the cache when they leave a server.
         *
         * @default true
         */
        removeMemberOnLeave?: boolean;
        /**
         * Whether to remove a member's ban from the cache when they are unbanned.
         *
         * @default true
         */
        removeMemberBanOnUnban?: boolean;
        /**
         * Whether to remove a channel from the cache when it is deleted.
         *
         * @default true
         */
        removeChannelOnDelete?: boolean;
        /**
         * Whether to remove a calendar from the cache when it is deleted.
         *
         * @default true
         */
        removeCalendarsOnDelete?: boolean;
        /**
         * Whether to remove a calendar RSVP from the cache when it is deleted.
         *
         * @default true
         */
        removeCalendarRsvpOnDelete?: boolean;
        /**
         * Whether to cache member bans.
         *
         * @default true
         */
        cacheMemberBans?: boolean;
        /**
         * Whether to cache webhooks.
         *
         * @default true
         */
        cacheWebhooks?: boolean;
        /**
         * Whether to cache channels.
         *
         * @default true
         */
        cacheChannels?: boolean;
        /**
         * Whether to cache servers.
         *
         * @default true
         */
        cacheServers?: boolean;
        /**
         * Whether to cache messages.
         *
         * @default true
         */
        cacheMessages?: boolean;
        /**
         * Whether to cache forum topics.
         *
         * @default true
         */
        cacheForumTopics?: boolean;
        /**
         * Whether to cache message reactions.
         *
         * @default true
         */
        cacheMessageReactions?: boolean;
        /**
         * Whether to cache calendars.
         *
         * @default true
         */
        cacheCalendars?: boolean;
        /**
         * Whether to cache calendar RSVPs.
         *
         * @default true
         */
        cacheCalendarsRsvps?: boolean;
        /**
         * Whether to cache member social links.
         *
         * @default true
         */
        cacheSocialLinks?: boolean;
    };
};
export {};
//# sourceMappingURL=Client.d.ts.map