import type { Collection } from "@discordjs/collection";
import type { ChannelsService, ChatService, ServerChannelPayload } from "@guildedjs/api";
import type { MessageContent, OptionBody } from "../../typings";
import { Base } from "../Base";
import type { Client } from "../Client";
import type { Message } from "../Message";
/**
 * Represents a channel in a server on Guilded.
 */
export declare class Channel extends Base {
    /**
     * The type of the channel.
     */
    type: ChannelType;
    /**
     * The name of the channel.
     */
    name: string;
    /**
     * The topic of the channel.
     */
    topic: string | null;
    /**
     * The timestamp when the channel was created.
     */
    _createdAt: number;
    /**
     * The user ID of the user who created the channel.
     */
    createdBy: string;
    /**
     * The timestamp when the channel was last updated.
     */
    _updatedAt: number | null;
    /**
     * The ID of the server that the channel belongs to.
     */
    serverId: string;
    /**
     * The ID of the parent channel.
     */
    parentId: string | null;
    /**
     * The ID of the category that the channel belongs to.
     */
    categoryId: number | null;
    /**
     * The ID of the group that the channel belongs to.
     */
    groupId: string;
    /**
     * Whether the channel is public.
     */
    isPublic: boolean;
    /**
     * The user ID of the user who archived the channel.
     */
    archivedBy: string | null;
    /**
     * The timestamp when the channel was archived.
     */
    _archivedAt: number | null;
    constructor(client: Client, data: ServerChannelPayload & {
        deleted?: boolean;
    });
    /**
     * The timestamp when the channel was created as a Date object.
     */
    get createdAt(): Date;
    /**
     * The timestamp when the channel was archived as a Date object, or null if the channel is not archived.
     */
    get archivedAt(): Date | null;
    /**
     * The timestamp when the channel was last updated as a Date object, or null if the channel has not been updated.
     */
    get updatedAt(): Date | null;
    _update(data: Partial<ServerChannelPayload & {
        deleted?: boolean;
    }>): this;
    /**
     * Fetch from the latest 100 messages in the channel.
     *
     * @param options - Additional options for the message fetch.
     */
    fetchMessages(options?: OptionBody<ChatService["channelMessageReadMany"]>): Promise<Collection<string, Message>>;
    /**
     * Fetch details for a specific message in the channel.
     *
     * @param messageId - The ID of the message to fetch.
     */
    fetchMessage(messageId: string): Promise<Message>;
    /**
     * Update the channel with new data.
     *
     * @param options - The new data for the channel.
     */
    update(options: OptionBody<ChannelsService["channelUpdate"]>): Promise<Channel>;
    /**
     * Delete the channel.
     */
    delete(): Promise<Channel | null>;
    /**
     * Send a message in the channel.
     *
     * @param content - The content of the message.
     * @example
     * let replyObj = {
     *  content: 'This is text, supports **markdown**.',
     *  embeds: [{
     *    title: 'This is an embed title!',
     *    description: 'A description may go here'
     *  }]
     * };
     * channel.send(replyObj)
     */
    send(content: MessageContent): Promise<Message>;
}
/**
 * Enum for mapping channel types to an int for memory saving.
 */
export declare enum ChannelType {
    Announcements = 0,
    Chat = 1,
    Calendar = 2,
    Forums = 3,
    Media = 4,
    Docs = 5,
    Voice = 6,
    List = 7,
    Scheduling = 8,
    Stream = 9
}
/**
 * A map of API channel types to channel types.
 */
export declare const channelTypeToEnumMap: Record<ServerChannelPayload["type"], ChannelType>;
//# sourceMappingURL=Channel.d.ts.map