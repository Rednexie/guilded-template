"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalMemberManager = void 0;
const collection_1 = require("@discordjs/collection");
const structures_1 = require("../../structures");
const Member_1 = require("../../structures/Member");
const util_1 = require("../../util");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * A class representing a manager for Discord server members.
 *
 */
class GlobalMemberManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Whether or not social links should be cached.
     */
    get shouldCacheSocialLinks() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheSocialLinks) !== false;
    }
    /**
     * Fetches a member from a server.
     *
     * @param serverId The ID of the server to fetch the member from.
     * @param userId The ID of the member to fetch.
     * @param force Whether to force a fetch from the API.
     * @returns A Promise that resolves with the fetched member.
     */
    fetch(serverId, userId, force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (userId === "Ann6LewA")
                throw new Error("You cannot fetch a webhook as a member. The provided ID (Ann6LewA) is only given to webhooks.");
            const memberKey = (0, util_1.buildMemberKey)(serverId, userId);
            if (!force) {
                const existingMember = this.client.members.cache.get(memberKey);
                if (existingMember)
                    return existingMember;
            }
            const data = yield this.client.rest.router.members.serverMemberRead({
                serverId,
                userId,
            });
            const newMember = new Member_1.Member(this.client, Object.assign(Object.assign({}, data.member), { serverId, id: data.member.user.id }));
            this.client.users.cache.set(data.member.user.id, new structures_1.User(this.client, data.member.user));
            this.client.members.cache.set(memberKey, newMember);
            return newMember;
        });
    }
    /**
     * Fetches all members from a server. Returned objects are partial members.
     *
     * @param serverId The ID of the server to fetch members from.
     * @returns A Promise that resolves with a collection of partial members.
     */
    fetchMany(serverId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.members.serverMemberReadMany({
                serverId,
            });
            const members = new collection_1.Collection();
            for (const member of data.members) {
                const newMember = new Member_1.PartialMember(this.client, Object.assign({ serverId, id: member.user.id }, member));
                members.set(newMember.id, newMember);
            }
            return members;
        });
    }
    /**
     * Kicks a member from a server.
     *
     * @param serverId The ID of the server to kick the member from.
     * @param userId The ID of the member to kick.
     * @returns A Promise that resolves with the kicked member, or null if the member was not cached.
     */
    kick(serverId, userId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.members.serverMemberDelete({
                serverId,
                userId,
            });
            return (_a = this.client.members.cache.get((0, util_1.buildMemberKey)(serverId, userId))) !== null && _a !== void 0 ? _a : null;
        });
    }
    /**
     * Bans a member from a server.
     *
     * @param serverId The ID of the server to ban the member from.
     * @param userId The ID of the user to ban.
     * @returns A Promise that resolves with the banned member, or null if the member was not cached.
     */
    ban(serverId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.bans.ban(serverId, userId);
        });
    }
    /**
     * Unbans a user from a server.
     *
     * @param serverId The ID of the server.
     * @param userId The ID of the user.
     * @param removeBanIfCached Whether to remove the ban from the cache if it exists.
     * @returns A Promise that resolves with the unbanned member ban or `null` if it isn't cached.
     */
    unban(serverId, userId, removeBanIfCached = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.bans.unban(serverId, userId, removeBanIfCached);
        });
    }
    /**
     * Gets a list of the roles assigned to a member using the ID of the member.
     *
     * @param serverId The ID of the server to get the member roles from.
     * @param userId The ID of the member to get the roles for.
     * @returns A Promise that resolves with an array of role IDs.
     */
    getRoles(serverId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.roleMembership.roleMembershipReadMany({
                serverId,
                userId,
            });
            return data.roleIds;
        });
    }
    /**
     * Updates a member's nickname. Returns the new name.
     *
     * @param serverId The ID of the server to update the member nickname for.
     * @param userId The ID of the member to update the nickname for.
     * @param newNickname The new nickname for the member.
     * @returns A Promise that resolves with the updated nickname.
     */
    updateNickname(serverId, userId, newNickname) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.members.memberNicknameUpdate({
                serverId,
                userId,
                requestBody: { nickname: newNickname },
            });
            return data.nickname;
        });
    }
    /**
     * Deletes a member's nickname.
     *
     * @param serverId The ID of the server to delete the member nickname from.
     * @param userId The ID of the member to delete the nickname for.
     * @returns A Promise that resolves with no value upon completion.
     */
    resetNickname(serverId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.members.memberNicknameDelete({
                serverId,
                userId,
            });
        });
    }
    /**
     * Awards XP to a member.
     *
     * @param serverId The ID of the server to award XP on.
     * @param userId The ID of the member to award XP to.
     * @param amount The amount of XP to award.
     * @returns A Promise that resolves with the member's new total XP.
     */
    giveXP(serverId, userId, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.serverXp.serverXpForUserCreate({
                serverId,
                userId,
                requestBody: { amount },
            });
            return data.total;
        });
    }
    /**
     * Fetch a member's social links.
     *
     * @param serverId The ID of the server.
     * @param userId The ID of the member.
     * @param type The type of social link to fetch.
     * @returns A Promise that resolves with the member's social link.
     */
    fetchSocialLinks(serverId, userId, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.socialLinks.memberSocialLinkRead({ serverId, userId, socialLinkType: type });
            const existingMember = this.cache.get((0, util_1.buildMemberKey)(serverId, userId));
            if (this.shouldCacheSocialLinks)
                existingMember === null || existingMember === void 0 ? void 0 : existingMember.socialLinks.set(data.socialLink.type, data.socialLink);
            return data.socialLink;
        });
    }
}
exports.GlobalMemberManager = GlobalMemberManager;
//# sourceMappingURL=MemberManager.js.map