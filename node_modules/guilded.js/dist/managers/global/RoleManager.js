"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalRoleManager = void 0;
const collection_1 = require("@discordjs/collection");
const structures_1 = require("../../structures");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * A class representing a global role manager. At the moment, we don't cache roles in this structure.
 */
class GlobalRoleManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Create a new role.
     *
     * @param serverId The ID of the server.
     * @param options Role creation options.
     * @returns Promise that resolves with the newly created role.
     */
    create(serverId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.roles.roleCreate({
                serverId,
                requestBody: options,
            });
            const newRole = new structures_1.Role(this.client, data.role);
            this.cache.set(newRole.id, newRole);
            return newRole;
        });
    }
    /**
     * Fetch a role by its ID
     *
     * @param serverId The ID of the server.
     * @param roleId ID of the role to fetch.
     * @param force Whether or not to force a fetch from the API.
     * @returns Promise that resolves with the fetched role.
     */
    fetch(serverId, roleId, force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                const existingRole = this.client.roles.cache.get(roleId);
                if (existingRole)
                    return existingRole;
            }
            const data = yield this.client.rest.router.roles.roleRead({
                serverId,
                roleId,
            });
            const fetchedRole = new structures_1.Role(this.client, data.role);
            this.cache.set(fetchedRole.id, fetchedRole);
            return fetchedRole;
        });
    }
    /**
     * Fetch all roles in a given server.
     *
     * @param serverId The ID of the server.
     * @returns Promise that resolves with a Collection of fetched roles.
     */
    fetchMany(serverId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.roles.roleReadMany({ serverId });
            const roles = new collection_1.Collection();
            // Insert all fetched roles into cache
            for (const role of data.roles) {
                const fetchedRole = new structures_1.Role(this.client, role);
                this.cache.set(fetchedRole.id, fetchedRole);
                roles.set(fetchedRole.id, fetchedRole);
            }
            return roles;
        });
    }
    /**
     * Update a role by ID.
     *
     * @param serverId The ID of the server.
     * @param roleId ID of the role to update.
     * @param options Role update options.
     * @returns Promise that resolves with the updated role.
     */
    update(serverId, roleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.roles.roleUpdate({
                serverId,
                roleId,
                requestBody: options,
            });
            const existingRole = this.cache.get(roleId);
            if (existingRole)
                return existingRole._update(data.role);
            const newRole = new structures_1.Role(this.client, data.role);
            this.cache.set(newRole.id, newRole);
            return newRole;
        });
    }
    /**
     * Delete a role by ID.
     *
     * @param serverId ID of the server to delete the role.
     * @param roleId ID of the role to delete.
     * @returns Promise that resolves with the cached deleted role, or null if the role isn't present in the cache.
     */
    delete(serverId, roleId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.roles.roleDelete({ serverId, roleId });
            const cachedRole = this.cache.get(roleId);
            return cachedRole !== null && cachedRole !== void 0 ? cachedRole : null;
        });
    }
    /**
     * Updates the permissions of a role.
     *
     * @param serverId The ID of the server.
     * @param roleId The ID of the role.
     * @param options Role permission update options.
     * @returns A Promise that resolves with no value upon successful completion.
     */
    updatePermissions(serverId, roleId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.roles.rolePermissionUpdate({
                serverId,
                roleId,
                requestBody: options,
            });
        });
    }
    /**
     * Awards XP to a role.
     *
     * @param serverId The ID of the server.
     * @param roleId The ID of the role.
     * @param amount The amount of XP to award.
     * @returns A Promise that resolves with the total XP awarded to the role.
     */
    giveXP(serverId, roleId, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.serverXp.serverXpForRoleCreate({
                serverId,
                roleId,
                requestBody: { amount },
            });
        });
    }
    /**
     * Assigns a role to a member.
     *
     * @param serverId The ID of the server.
     * @param userId The ID of the member.
     * @param roleId The ID of the role.
     * @returns A Promise that resolves with no value upon successful completion.
     */
    addRoleToMember(serverId, userId, roleId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.roleMembership.roleMembershipCreate({
                serverId,
                userId,
                roleId,
            });
        });
    }
    /**
     * Removes a role from a member.
     *
     * @param serverId The ID of the server.
     * @param userId The ID of the member.
     * @param roleId The ID of the role.
     * @returns A Promise that resolves with no value upon successful completion.
     */
    removeRoleFromMember(serverId, userId, roleId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.roleMembership.roleMembershipDelete({
                serverId,
                userId,
                roleId,
            });
        });
    }
}
exports.GlobalRoleManager = GlobalRoleManager;
//# sourceMappingURL=RoleManager.js.map