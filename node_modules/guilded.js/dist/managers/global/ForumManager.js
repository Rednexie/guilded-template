"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalForumTopicManager = void 0;
const collection_1 = require("@discordjs/collection");
const Forum_1 = require("../../structures/Forum");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * Manager for interacting with forum topics at a global level.
 */
class GlobalForumTopicManager extends CacheableStructManager_1.CacheableStructManager {
    get shouldCacheForumTopic() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheForumTopics) !== false;
    }
    /**
     * Create a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param options The options for creating the forum topic.
     * @returns A Promise that resolves with the payload of the created forum topic.
     */
    create(channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.forums.forumTopicCreate({
                channelId,
                requestBody: options,
            });
            return new Forum_1.ForumTopic(this.client, data.forumTopic);
        });
    }
    /**
     * Get all topics in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param options The options for filtering the forum topics.
     * @returns A Promise that resolves to a Collection of ForumTopics.
     */
    fetchMany(channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.forums.forumTopicReadMany(Object.assign({ channelId }, options));
            const topics = new collection_1.Collection();
            for (const forumTopic of data.forumTopics) {
                const newTopic = new Forum_1.PartialForumTopic(this.client, forumTopic);
                topics.set(newTopic.id, newTopic);
            }
            return topics;
        });
    }
    /**
     * Get a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumTopicId The ID of the forum topic.
     * @returns a Promise that resolves to a ForumTopic.
     */
    fetch(channelId, forumTopicId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.forums.forumTopicRead({
                channelId,
                forumTopicId,
            });
            return new Forum_1.ForumTopic(this.client, data.forumTopic);
        });
    }
    /**
     * Update a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumTopicId The ID of the forum topic.
     * @param options The options for updating the forum topic.
     * @returns A Promise that resolves to the updated ForumTopic. If cached locally, it will modify that object.
     */
    update(channelId, forumTopicId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.forums.forumTopicUpdate({
                channelId,
                forumTopicId,
                requestBody: options,
            });
            const existingTopic = this.client.topics.cache.get(data.forumTopic.id);
            if (existingTopic)
                return existingTopic._update(data.forumTopic);
            const newTopic = new Forum_1.ForumTopic(this.client, data.forumTopic);
            this.client.topics.cache.set(newTopic.id, newTopic);
            return newTopic;
        });
    }
    /**
     * Delete a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumTopicId The ID of the forum topic.
     * @returns A Promise that resolves to nothing.
     */
    delete(channelId, forumTopicId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.forums.forumTopicDelete({
                channelId,
                forumTopicId,
            });
        });
    }
    /**
     * Pin a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumTopicId The ID of the forum topic.
     * @returns A Promise that resolves to nothing.
     */
    pin(channelId, forumTopicId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.forums.forumTopicPin({
                channelId,
                forumTopicId,
            });
        });
    }
    /**
     * Unpin a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumTopicId The ID of the forum topic.
     * @returns A Promise that resolves to nothing.
     */
    unpin(channelId, forumTopicId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.forums.forumTopicUnpin({
                channelId,
                forumTopicId,
            });
        });
    }
    /**
     * Lock a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumTopicId The ID of the forum topic.
     * @returns A Promise that resolves to nothing.
     */
    lock(channelId, forumTopicId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.forums.forumTopicLock({
                channelId,
                forumTopicId,
            });
        });
    }
    /**
     * Unlock a topic in a forum.
     *
     * @param channelId The ID of the channel containing the forum.
     * @param forumTopicId The ID
     * @returns A Promise that resolves to nothing.
     */
    unlock(channelId, forumTopicId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.forums.forumTopicUnlock({
                channelId,
                forumTopicId,
            });
        });
    }
}
exports.GlobalForumTopicManager = GlobalForumTopicManager;
//# sourceMappingURL=ForumManager.js.map