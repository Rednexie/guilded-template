"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalGuildBanManager = void 0;
const collection_1 = require("@discordjs/collection");
const Member_1 = require("../../structures/Member");
const util_1 = require("../../util");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * Manages guild bans in all servers.
 */
class GlobalGuildBanManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Returns whether bans should be cached.
     */
    get shouldCacheBan() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheMemberBans) !== false;
    }
    /**
     * Fetches a member ban in a server.
     *
     * @param serverId The ID of the server.
     * @param userId The ID of the user.
     * @param force Whether to force fetch the ban even if it's cached.
     * @returns A Promise that resolves with the fetched member ban.
     */
    fetch(serverId, userId, force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                const existingMemberBan = this.client.bans.cache.get((0, util_1.buildMemberKey)(serverId, userId));
                if (existingMemberBan)
                    return existingMemberBan;
            }
            const data = yield this.client.rest.router.memberBans.serverMemberBanRead({
                serverId,
                userId,
            });
            const newMemberBan = new Member_1.MemberBan(this.client, Object.assign(Object.assign({}, data.serverMemberBan), { serverId }));
            if (this.shouldCacheBan)
                this.client.bans.cache.set(newMemberBan.id, newMemberBan);
            return newMemberBan;
        });
    }
    /**
     * Fetches all bans in a server.
     *
     * @param serverId The ID of the server.
     * @returns A Promise that resolves with a collection of the fetched member bans.
     */
    fetchMany(serverId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.memberBans.serverMemberBanReadMany({
                serverId,
            });
            const newMemberBans = new collection_1.Collection();
            for (const ban of data.serverMemberBans) {
                const newMemberBan = new Member_1.MemberBan(this.client, Object.assign({ serverId }, ban));
                newMemberBans.set(newMemberBan.id, newMemberBan);
                if (this.shouldCacheBan)
                    this.client.bans.cache.set(newMemberBan.id, newMemberBan);
            }
            return newMemberBans;
        });
    }
    /**
     * Bans a user from a server.
     *
     * @param serverId The ID of the server.
     * @param userId The ID of the user.
     * @returns A Promise that resolves with the newly created member ban.
     */
    ban(serverId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.memberBans.serverMemberBanCreate({ serverId, userId });
            const newMemberBan = new Member_1.MemberBan(this.client, Object.assign({ serverId }, data.serverMemberBan));
            if (this.shouldCacheBan)
                this.client.bans.cache.set(newMemberBan.id, newMemberBan);
            return newMemberBan;
        });
    }
    /**
     * Unbans a user from a server.
     *
     * @param serverId The ID of the server.
     * @param userId The ID of the user.
     * @param removeBanIfCached Whether to remove the ban from the cache if it exists.
     * @returns A Promise that resolves with the unbanned member ban or `null` if it isn't cached.
     */
    unban(serverId, userId, removeBanIfCached = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.memberBans.serverMemberBanDelete({
                serverId,
                userId,
            });
            const memberKey = (0, util_1.buildMemberKey)(serverId, userId);
            const existingBan = this.client.bans.cache.get(memberKey);
            if (((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.removeMemberBanOnUnban) || removeBanIfCached)
                this.client.bans.cache.delete(memberKey);
            return existingBan !== null && existingBan !== void 0 ? existingBan : null;
        });
    }
}
exports.GlobalGuildBanManager = GlobalGuildBanManager;
//# sourceMappingURL=GuildBanManager.js.map