"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalWebhookManager = void 0;
const collection_1 = require("@discordjs/collection");
const Webhook_1 = require("../../structures/Webhook");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * A manager for interacting with global webhooks. You can retrieve webhooks from the .cache property
 *
 * @extends CacheableStructManager
 */
class GlobalWebhookManager extends CacheableStructManager_1.CacheableStructManager {
    get shouldCacheWebhook() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheWebhooks) !== false;
    }
    /**
     * Create a webhook
     *
     * @param serverId The ID of the server to create the webhook for
     * @param options The options for creating the webhook
     * @returns A Promise that resolves to the created webhook
     */
    create(serverId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.webhook.webhookCreate({
                serverId,
                requestBody: options,
            });
            const existingWebhook = this.client.webhooks.cache.get(data.webhook.id);
            if (existingWebhook)
                return existingWebhook;
            const newWebhook = new Webhook_1.Webhook(this.client, data.webhook);
            if (this.shouldCacheWebhook)
                this.cache.set(newWebhook.id, newWebhook);
            return newWebhook;
        });
    }
    /**
     * Get a server's webhooks
     *
     * @param serverId The ID of the server to get webhooks for
     * @param channelId The ID of the channel to get webhooks for
     * @returns A Promise that resolves to a Collection of Webhooks
     */
    fetchMany(serverId, channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.webhook.webhookReadMany({
                serverId,
                channelId,
            });
            const webhooks = new collection_1.Collection();
            for (const webhook of data.webhooks) {
                const newWebhook = new Webhook_1.Webhook(this.client, webhook);
                webhooks.set(newWebhook.id, newWebhook);
                if (this.shouldCacheWebhook)
                    this.cache.set(newWebhook.id, newWebhook);
            }
            return webhooks;
        });
    }
    /**
     * Get a webhook
     *
     * @param serverId The ID of the server the webhook is in
     * @param webhookId The ID of the webhook
     * @param force Whether to skip the cache check and request the API
     * @returns A Promise that resolves to the fetched webhook
     */
    fetch(serverId, webhookId, force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                const existingWebhook = this.client.webhooks.cache.get(webhookId);
                if (existingWebhook)
                    return existingWebhook;
            }
            const data = yield this.client.rest.router.webhook.webhookRead({
                serverId,
                webhookId,
            });
            const newWebhook = new Webhook_1.Webhook(this.client, data.webhook);
            if (this.shouldCacheWebhook)
                this.cache.set(newWebhook.id, newWebhook);
            return newWebhook;
        });
    }
    /**
     * Update a webhook
     *
     * @param serverId The ID of the server the webhook is in
     * @param webhookId The ID of the webhook to update
     * @param options The options for updating the webhook
     * @returns A Promise that resolves to the updated Webhook
     */
    update(serverId, webhookId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.webhook.webhookUpdate({
                serverId,
                webhookId,
                requestBody: options,
            });
            const existingWebhook = this.cache.get(data.webhook.id);
            if (existingWebhook) {
                existingWebhook._update(data.webhook);
                return existingWebhook;
            }
            return new Webhook_1.Webhook(this.client, data.webhook);
        });
    }
    /**
     * Delete a webhook
     *
     * @param serverId The ID of the server the webhook is in
     * @param webhookId The ID of the webhook to delete
     * @returns A Promise that resolves with no value upon successful deletion
     */
    delete(serverId, webhookId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.webhook.webhookDelete({
                serverId,
                webhookId,
            });
        });
    }
}
exports.GlobalWebhookManager = GlobalWebhookManager;
//# sourceMappingURL=WebhookManager.js.map