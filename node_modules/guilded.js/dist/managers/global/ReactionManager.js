"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalReactionManager = void 0;
const structures_1 = require("../../structures");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * A class representing a global reaction manager that extends the CacheableStructManager class.
 */
class GlobalReactionManager extends CacheableStructManager_1.CacheableStructManager {
    get shouldCacheReaction() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheMessageReactions) !== false;
    }
    /**
     * Adds a reaction emote to a message.
     *
     * @param channelId The ID of the channel where the message was sent.
     * @param messageId The ID of the message.
     * @param emoteId The ID of the emote to add.
     * @returns A Promise that resolves with no value upon successful completion.
     */
    create(channelId, messageId, emoteId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.reactions.channelMessageReactionCreate({
                channelId,
                messageId,
                emoteId,
            });
        });
    }
    /**
     * Deletes either a whole reaction emote from a message or a specific user's if a userId is provided.
     *
     * @param channelId The ID of the channel where the message was sent.
     * @param messageId The ID of the message.
     * @param emoteId The ID of the emote to delete.
     * @returns A Promise that resolves with no value upon successful completion.
     */
    delete(channelId, messageId, emoteId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.reactions.channelMessageReactionDelete({
                channelId,
                messageId,
                emoteId,
                userId,
            });
        });
    }
    /**
     * Wait & collect reactions on a message.
     *
     * @param messageId ID of the message to listen for reactions on
     * @param options Configuration for the collector
     * @returns A Promise that resolves with a collection of reactions collected, with the ID as the key and the reaction as the value
     * @example
     * const reactions = await client.reactions.awaitReactions('message-id-here', { max: 4, time: 60_000 });
     */
    awaitReactions(messageId, options) {
        return new structures_1.ReactionCollector(this.client, Object.assign(Object.assign({}, options), { filter: (item) => {
                var _a, _b;
                if (item.messageId !== messageId)
                    return false;
                return (_b = (_a = options.filter) === null || _a === void 0 ? void 0 : _a.call(options, item)) !== null && _b !== void 0 ? _b : true;
            } })).start();
    }
}
exports.GlobalReactionManager = GlobalReactionManager;
//# sourceMappingURL=ReactionManager.js.map