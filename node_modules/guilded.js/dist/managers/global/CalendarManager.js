"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalCalendarManager = void 0;
const collection_1 = require("@discordjs/collection");
const CalendarEvent_1 = require("../../structures/CalendarEvent");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * The manager is used to interact with calendars on a server.
 */
class GlobalCalendarManager extends CacheableStructManager_1.CacheableStructManager {
    get shouldCacheCalendar() {
        var _a, _b;
        return ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheCalendars) !== false;
    }
    get shouldCacheCalendarRsvps() {
        var _a, _b;
        return ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheCalendarsRsvps) !== false;
    }
    /**
     * Creates a calendar event.
     *
     * @param channelId The ID of the channel in which to create the event.
     * @param options The options for the event.
     * @returns A promise that resolves with the created calendar event.
     */
    create(channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.calendarEvents.calendarEventCreate({
                channelId,
                requestBody: options,
            });
            return new CalendarEvent_1.CalendarEvent(this.client, data.calendarEvent);
        });
    }
    /**
     * Fetches a single calendar event.
     *
     * @param channelId The ID of the channel in which to fetch the event.
     * @param calendarEventId The ID of the event to fetch.
     * @param force Whether or not to force a fetch instead of using a cached version.
     * @returns A promise that resolves with the fetched calendar event.
     */
    fetch(channelId, calendarEventId, force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                const existingCalendar = this.client.calendars.cache.get(calendarEventId);
                if (existingCalendar)
                    return existingCalendar;
            }
            const data = yield this.client.rest.router.calendarEvents.calendarEventRead({ channelId, calendarEventId });
            const newCalendar = new CalendarEvent_1.CalendarEvent(this.client, data.calendarEvent);
            if (this.shouldCacheCalendar)
                this.client.calendars.cache.set(newCalendar.id, newCalendar);
            return newCalendar;
        });
    }
    /**
     * Fetches multiple calendar events.
     *
     * @param channelId The ID of the channel in which to fetch the events.
     * @param options The options for the fetch.
     * @returns A promise that resolves with a collection of the fetched calendar events.
     */
    fetchMany(channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.calendarEvents.calendarEventReadMany(Object.assign({ channelId }, options));
            const calendarEvents = new collection_1.Collection();
            for (const calendarEvent of data.calendarEvents) {
                const newCalendar = new CalendarEvent_1.CalendarEvent(this.client, calendarEvent);
                calendarEvents.set(newCalendar.id, newCalendar);
                if (this.shouldCacheCalendar)
                    this.client.calendars.cache.set(newCalendar.id, newCalendar);
            }
            return calendarEvents;
        });
    }
    /**
     * Updates a calendar event.
     *
     * @param channelId The ID of the channel in which the event exists.
     * @param calendarEventId The ID of the event to update.
     * @param options The options for the update.
     * @returns A promise that resolves with the updated calendar event.
     */
    update(channelId, calendarEventId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.calendarEvents.calendarEventUpdate({
                channelId,
                calendarEventId,
                requestBody: options,
            });
            const existingCalendar = this.cache.get(calendarEventId);
            if (existingCalendar)
                return existingCalendar._update(data.calendarEvent);
            const newCalendar = new CalendarEvent_1.CalendarEvent(this.client, data.calendarEvent);
            if (this.shouldCacheCalendar)
                this.cache.set(newCalendar.id, newCalendar);
            return newCalendar;
        });
    }
    /**
     * Delete a calendar event.
     *
     * @param channelId - The ID of the channel where the calendar event is located.
     * @param calendarEventId - The ID of the calendar event to delete.
     * @returns A Promise that resolves with the deleted calendar event or `undefined` if the event was not cached.
     */
    delete(channelId, calendarEventId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.calendarEvents.calendarEventDelete({
                channelId,
                calendarEventId,
            });
            const cachedCalendar = this.cache.get(calendarEventId);
            return cachedCalendar !== null && cachedCalendar !== void 0 ? cachedCalendar : null;
        });
    }
    /**
     * Get a single RSVP from a calendar event.
     *
     * @param channelId - The ID of the channel where the calendar event is located.
     * @param calendarEventId - The ID of the calendar event to get the RSVP from.
     * @param userId - The ID of the user who made the RSVP.
     * @param force - Whether to force a request to the API instead of returning the cached RSVP.
     * @returns A Promise that resolves with the requested RSVP.
     */
    fetchRsvp(channelId, calendarEventId, userId, force) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                const existingRsvp = (_b = (_a = this.client.calendars.cache.get(calendarEventId)) === null || _a === void 0 ? void 0 : _a.rsvps) === null || _b === void 0 ? void 0 : _b.get(userId);
                if (existingRsvp)
                    return existingRsvp;
            }
            const data = yield this.client.rest.router.calendarEvents.calendarEventRsvpRead({
                channelId,
                calendarEventId,
                userId,
            });
            const newRsvp = new CalendarEvent_1.CalendarEventRsvp(this.client, data.calendarEventRsvp);
            if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps)
                (_d = (_c = this.cache.get(newRsvp.calendarEventId)) === null || _c === void 0 ? void 0 : _c.rsvps) === null || _d === void 0 ? void 0 : _d.set(newRsvp.userId, newRsvp);
            return newRsvp;
        });
    }
    /**
     * Fetch RSVPs for a calendar event.
     *
     * @param channelId - The ID of the channel where the calendar event is located.
     * @param calendarEventId - The ID of the calendar event to fetch RSVPs for.
     * @returns A Promise that resolves with a collection of RSVPs.
     */
    fetchManyRsvps(channelId, calendarEventId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.calendarEvents.calendarEventRsvpReadMany({
                channelId,
                calendarEventId,
            });
            const rsvpEvents = new collection_1.Collection();
            for (const rsvpEvent of data.calendarEventRsvps) {
                if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps) {
                    const cachedCalendar = this.cache.get(calendarEventId);
                    (_a = cachedCalendar === null || cachedCalendar === void 0 ? void 0 : cachedCalendar.rsvps) === null || _a === void 0 ? void 0 : _a.set(rsvpEvent.userId, new CalendarEvent_1.CalendarEventRsvp(this.client, rsvpEvent));
                }
                rsvpEvents.set(rsvpEvent.userId, new CalendarEvent_1.CalendarEventRsvp(this.client, rsvpEvent));
            }
            return rsvpEvents;
        });
    }
    /**
     * Creates or updates an RSVP for a calendar event.
     *
     * @param channelId The ID of the channel.
     * @param calendarEventId The ID of the calendar event.
     * @param userId The ID of the user.
     * @param options The options for updating the RSVP.
     * @returns A promise that resolves with the updated or created RSVP.
     */
    updateRsvp(channelId, calendarEventId, userId, options) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.calendarEvents.calendarEventRsvpUpdate({
                channelId,
                calendarEventId,
                userId,
                requestBody: options,
            });
            const existingRsvp = (_b = (_a = this.cache.get(calendarEventId)) === null || _a === void 0 ? void 0 : _a.rsvps) === null || _b === void 0 ? void 0 : _b.get(userId);
            if (existingRsvp)
                return existingRsvp._update(data.calendarEventRsvp);
            const newRsvp = new CalendarEvent_1.CalendarEventRsvp(this.client, data.calendarEventRsvp);
            if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps)
                (_d = (_c = this.cache.get(calendarEventId)) === null || _c === void 0 ? void 0 : _c.rsvps) === null || _d === void 0 ? void 0 : _d.set(userId, newRsvp);
            return newRsvp;
        });
    }
    /**
     * Creates or updates multiple RSVPs for a calendar event.
     *
     * @param channelId The ID of the channel.
     * @param calendarEventId The ID of the calendar event.
     * @param options The options for updating many RSVP.
     */
    updateManyRsvp(channelId, calendarEventId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.calendarEvents.calendarEventRsvpUpdateMany({
                channelId,
                calendarEventId,
                requestBody: options,
            });
        });
    }
    /**
     * Deletes an RSVP for a calendar event.
     *
     * @param channelId The ID of the channel.
     * @param calendarEventId The ID of the calendar event.
     * @param userId The ID of the user.
     * @returns A promise that resolves with the deleted RSVP or void if it was not cached.
     */
    deleteRsvp(channelId, calendarEventId, userId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.calendarEvents.calendarEventRsvpDelete({
                channelId,
                calendarEventId,
                userId,
            });
            if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps) {
                const cachedCalendar = this.cache.get(calendarEventId);
                (_a = cachedCalendar === null || cachedCalendar === void 0 ? void 0 : cachedCalendar.rsvps) === null || _a === void 0 ? void 0 : _a.delete(userId);
            }
        });
    }
}
exports.GlobalCalendarManager = GlobalCalendarManager;
//# sourceMappingURL=CalendarManager.js.map