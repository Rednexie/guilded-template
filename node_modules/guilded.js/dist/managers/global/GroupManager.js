"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalGroupManager = void 0;
const collection_1 = require("@discordjs/collection");
const structures_1 = require("../../structures");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * Manager for interacting with Groups on Guilded.
 */
class GlobalGroupManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Creates a group.
     *
     * @param serverId The ID of the server to create the group in.
     * @param options The options for the group to create.
     * @returns A Promise that resolves with the created group.
     */
    create(serverId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.groups.groupCreate({
                serverId,
                requestBody: options,
            });
            const createdGroup = new structures_1.Group(this.client, data.group);
            this.cache.set(createdGroup.id, createdGroup);
            return createdGroup;
        });
    }
    /**
     * Fetch a group
     *
     * @param serverId The ID of the server to fetch the group from.
     * @param groupId The ID of the group to fetch.
     * @returns A Promise that resolves with the fetched group.
     */
    fetch(serverId, groupId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.groups.groupRead({
                serverId,
                groupId,
            });
            const fetchedGroup = new structures_1.Group(this.client, data.group);
            this.cache.set(fetchedGroup.id, fetchedGroup);
            return fetchedGroup;
        });
    }
    /**
     * Fetch all the groups in a server
     *
     * @param serverId The ID of the server to fetch the groups from.
     * @returns A Promise that resolves a Collection containing the fetched groups.
     */
    fetchMany(serverId) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.groups.groupReadMany({
                serverId,
            });
            const groups = new collection_1.Collection();
            for (const group of data.groups) {
                const fetchedGroup = new structures_1.Group(this.client, group);
                this.cache.set(fetchedGroup.id, fetchedGroup);
                groups.set(fetchedGroup.id, fetchedGroup);
            }
            return groups;
        });
    }
    /**
     * Update a group
     *
     * @param serverId The ID of the server to update the group in.
     * @param groupId The ID of the group to update.
     * @param options The options to update the group with.
     * @returns A Promise that resolves with the updated group.
     */
    update(serverId, groupId, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.groups.groupUpdate({
                serverId,
                groupId,
                requestBody: options,
            });
            let group = (_a = this.cache.get(data.group.id)) === null || _a === void 0 ? void 0 : _a._update(data.group);
            group !== null && group !== void 0 ? group : (group = new structures_1.Group(this.client, data.group));
            return group;
        });
    }
    /**
     * Delete a group
     *
     * @param serverId The ID of the server to delete the group from.
     * @param groupId The ID of the group to delete.
     * @returns A Promise that resolves when the operation is complete.
     */
    delete(serverId, groupId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.groups.groupDelete({ serverId, groupId });
            if (this.cache.has(groupId))
                this.cache.delete(groupId);
        });
    }
    /**
     * Adds a member to a group.
     *
     * @param groupId The ID of the group.
     * @param userId The ID of the user to add.
     * @returns A Promise that resolves when the operation is complete.
     */
    addMember(groupId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.groupMembership.groupMembershipCreate({
                groupId,
                userId,
            });
        });
    }
    /**
     * Removes a member from a group.
     *
     * @param groupId The ID of the group.
     * @param userId The ID of the user to remove.
     * @returns A Promise that resolves when the operation is complete.
     */
    removeMember(groupId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.groupMembership.groupMembershipDelete({
                groupId,
                userId,
            });
        });
    }
}
exports.GlobalGroupManager = GlobalGroupManager;
//# sourceMappingURL=GroupManager.js.map