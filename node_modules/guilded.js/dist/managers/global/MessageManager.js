"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalMessageManager = void 0;
const collection_1 = require("@discordjs/collection");
const structures_1 = require("../../structures");
const Message_1 = require("../../structures/Message");
const util_1 = require("../../util");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * Manager for handling caching and interactions for Messages
 */
class GlobalMessageManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Whether or not messages should be cached.
     */
    get shouldCacheMessage() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheMessages) !== false;
    }
    /**
     * Fetches multiple messages from a channel.
     *
     * @param channelId The ID of the channel to fetch messages from.
     * @param options Additional options for the fetch.
     * @returns A promise that resolves with a collection of messages.
     */
    fetchMany(channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.chat.channelMessageReadMany(Object.assign({ channelId }, options));
            const messages = new collection_1.Collection();
            for (const message of data.messages) {
                const newMessage = new Message_1.Message(this.client, message);
                messages.set(newMessage.id, newMessage);
            }
            return messages;
        });
    }
    /**
     * Fetches a message from a channel.
     *
     * @param channelId The ID of the channel to fetch the message from.
     * @param messageId The ID of the message to fetch.
     * @param force Whether or not to force the fetch.
     * @returns A promise that resolves with the requested message.
     */
    fetch(channelId, messageId, force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                const existingMessage = this.client.messages.cache.get(messageId);
                if (existingMessage)
                    return existingMessage;
            }
            const data = yield this.client.rest.router.chat.channelMessageRead({
                channelId,
                messageId,
            });
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /**
     * Sends a message to a channel.
     *
     * @param channelId The ID of the channel to send the message to.
     * @param content The content of the message.
     * @returns A promise that resolves with the created message.
     * @example
     * let replyObj = {
     *  content: 'This is text, supports **markdown**.',
     *  embeds: [{
     *    title: 'This is an embed title!',
     *    description: 'A description may go here'
     *  }]
     * };
     * await message.client.messages.send(message.channelId, replyObj)
     */
    send(channelId, content) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.chat.channelMessageCreate({
                channelId,
                requestBody: (0, util_1.resolveContentToData)(content),
            });
            const existingMessage = this.client.messages.cache.get(data.message.id);
            if (existingMessage)
                return existingMessage;
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /**
     * Adds a reaction to a message.
     *
     * @param channelId The ID of the channel containing the message.
     * @param contentId The ID of the message to add a reaction to.
     * @param emoteId The ID of the emote to add as a reaction.
     * @returns A promise that resolves to nothing when the reaction is added.
     */
    addReaction(channelId, contentId, emoteId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.reactions.create(channelId, contentId, emoteId);
        });
    }
    /**
     * Deletes either a whole reaction emote from a message or a specific user's if a userId is provided.
     *
     * @param channelId The ID of the channel containing the message.
     * @param contentId The ID of the message to delete the reaction from.
     * @param emoteId The ID of the emote to delete as a reaction.
     * @returns A promise that resolves to nothing when the reaction is deleted.
     */
    deleteReaction(channelId, contentId, emoteId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.reactions.delete(channelId, contentId, emoteId, userId);
        });
    }
    /**
     * Updates a message in a channel.
     *
     * @param channelId The ID of the channel containing the message.
     * @param messageId The ID of the message to update.
     * @param content The new content of the message.
     * @returns A promise that resolves with the updated message.
     */
    update(channelId, messageId, content) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.chat.channelMessageUpdate({
                channelId,
                messageId,
                requestBody: (0, util_1.resolveContentToData)(content),
            });
            const existingMessage = this.client.messages.cache.get(data.message.id);
            if (existingMessage)
                return existingMessage._update(data.message);
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /** Delete a channel message. */
    delete(channelId, messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.chat.channelMessageDelete({
                channelId,
                messageId,
            });
        });
    }
    awaitMessages(channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new structures_1.MessageCollector(this.client, Object.assign(Object.assign({}, options), { filter: (item) => {
                    var _a, _b;
                    if (item.channelId !== channelId)
                        return false;
                    return (_b = (_a = options.filter) === null || _a === void 0 ? void 0 : _a.call(options, item)) !== null && _b !== void 0 ? _b : true;
                } })).start();
        });
    }
}
exports.GlobalMessageManager = GlobalMessageManager;
//# sourceMappingURL=MessageManager.js.map