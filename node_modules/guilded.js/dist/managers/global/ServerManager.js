"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalServerManager = void 0;
const Server_1 = require("../../structures/Server");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * A class representing a global server manager. You can retrieve servers from the .cache property
 *
 * @extends CacheableStructManager
 */
class GlobalServerManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Determines whether or not servers should be cached.
     */
    get shouldCacheServer() {
        var _a, _b;
        return ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheServers) !== false;
    }
    /**
     * Fetches a server.
     *
     * @param serverId The ID of the server to fetch.
     * @param force Whether or not to force a fetch instead of using the cache.
     * @returns A Promise that resolves with the fetched server.
     * @example client.servers.fetch(message.serverId)
     */
    fetch(serverId, force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                const existingServer = this.client.servers.cache.get(serverId);
                if (existingServer)
                    return existingServer;
            }
            const data = yield this.client.rest.router.servers.serverRead({ serverId });
            const newServer = new Server_1.Server(this.client, data.server);
            if (this.shouldCacheServer)
                this.cache.set(newServer.id, newServer);
            return newServer;
        });
    }
}
exports.GlobalServerManager = GlobalServerManager;
//# sourceMappingURL=ServerManager.js.map