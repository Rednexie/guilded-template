"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeToChannel = exports.transformTypeToChannel = exports.GlobalChannelManager = void 0;
const structures_1 = require("../../structures");
const ThreadChannel_1 = require("../../structures/channels/ThreadChannel");
const CacheableStructManager_1 = require("./CacheableStructManager");
/**
 * Manages channels on the global scope. This can hold channels of any type, with all of them extending Channel.
 * You will likely need to cast the returned values from cache or fetches
 *
 * @extends CacheableStructManager
 */
class GlobalChannelManager extends CacheableStructManager_1.CacheableStructManager {
    /** Determine whether a channel should be cached or not */
    get shouldCacheChannel() {
        var _a, _b;
        return ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheChannels) !== false;
    }
    /**
     * Create a new channel
     *
     * @param options Channel creation options
     * @returns Promise that resolves with the newly created channel
     */
    create(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.channels.channelCreate({
                requestBody: options,
            });
            if (data.channel.messageId && data.channel.rootId && data.channel.parentId) {
                return new ThreadChannel_1.ThreadChannel(this.client, data.channel);
            }
            return new ((0, exports.transformTypeToChannel)(data.channel.type))(this.client, data.channel);
        });
    }
    /**
     * Fetch a channel by ID
     * Notice: if you're using TypeScript, you will need to upcast to your desired channel type.
     *
     * @param channelId ID of the channel to fetch
     * @param force Whether to force a fetch from the API
     * @returns Promise that resolves with the fetched channel
     */
    fetch(channelId, force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                const existingChannel = this.client.channels.cache.get(channelId);
                if (existingChannel)
                    return existingChannel;
            }
            const data = yield this.client.rest.router.channels.channelRead({
                channelId,
            });
            const fetchedChannel = new ((0, exports.transformTypeToChannel)(data.channel.type))(this.client, data.channel);
            if (this.shouldCacheChannel)
                this.cache.set(fetchedChannel.id, fetchedChannel);
            return fetchedChannel;
        });
    }
    /**
     * Update a channel by ID
     *
     * @param channelId ID of the channel to update
     * @param options Channel update options
     * @returns Promise that resolves with the updated channel
     */
    update(channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.client.rest.router.channels.channelUpdate({
                channelId,
                requestBody: options,
            });
            const existingChannel = this.cache.get(channelId);
            if (existingChannel)
                return existingChannel._update(data.channel);
            const newChannel = new ((0, exports.transformTypeToChannel)(data.channel.type))(this.client, data.channel);
            if (this.shouldCacheChannel)
                this.cache.set(newChannel.id, newChannel);
            return newChannel;
        });
    }
    /**
     * Delete a channel by ID
     *
     * @param channelId ID of the channel to delete
     * @returns Promise that resolves with the deleted channel, or null if not cached.
     */
    delete(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.channels.channelDelete({ channelId });
            const cachedChannel = this.cache.get(channelId);
            return cachedChannel !== null && cachedChannel !== void 0 ? cachedChannel : null;
        });
    }
    /**
     * Archive a channel by ID
     *
     * @param channelId ID of the channel to archive
     * @returns Promise that resolves with the archived channel or null if not cached
     */
    archive(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.channels.channelArchiveCreate({ channelId });
            const existingChannel = this.cache.get(channelId);
            return existingChannel !== null && existingChannel !== void 0 ? existingChannel : null;
        });
    }
    /**
     * Unarchive a channel by ID
     *
     * @param channelId ID of the channel to unarchive
     * @returns Promise that resolves with the unarchived channel or null if not cached
     */
    unarchive(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.rest.router.channels.channelArchiveDelete({ channelId });
            const existingChannel = this.cache.get(channelId);
            return existingChannel !== null && existingChannel !== void 0 ? existingChannel : null;
        });
    }
}
exports.GlobalChannelManager = GlobalChannelManager;
/**
 * Transforms the string APIChannelType to its corresponding channel class
 *
 * @param str String representing the channel type
 * @returns Channel class for the given channel type
 */
const transformTypeToChannel = (str) => { var _a; return (_a = exports.typeToChannel[str]) !== null && _a !== void 0 ? _a : structures_1.Channel; };
exports.transformTypeToChannel = transformTypeToChannel;
/** Mapping between the string APIChannelType and the corresponding channel class */
exports.typeToChannel = {
    chat: structures_1.ChatChannel,
    forums: structures_1.ForumChannel,
    docs: structures_1.DocChannel,
    list: structures_1.ListChannel,
};
//# sourceMappingURL=ChannelManager.js.map