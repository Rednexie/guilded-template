"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const node_events_1 = require("node:events");
const api_1 = require("@guildedjs/api");
const ClientGatewayHandler_1 = require("../gateway/ClientGatewayHandler");
const CalendarManager_1 = require("../managers/global/CalendarManager");
const CategoryManager_1 = require("../managers/global/CategoryManager");
const ChannelManager_1 = require("../managers/global/ChannelManager");
const DocManager_1 = require("../managers/global/DocManager");
const ForumManager_1 = require("../managers/global/ForumManager");
const GroupManager_1 = require("../managers/global/GroupManager");
const GuildBanManager_1 = require("../managers/global/GuildBanManager");
const ListManager_1 = require("../managers/global/ListManager");
const MemberManager_1 = require("../managers/global/MemberManager");
const MessageManager_1 = require("../managers/global/MessageManager");
const ReactionManager_1 = require("../managers/global/ReactionManager");
const RoleManager_1 = require("../managers/global/RoleManager");
const ServerManager_1 = require("../managers/global/ServerManager");
const SubscriptionManager_1 = require("../managers/global/SubscriptionManager");
const UserManager_1 = require("../managers/global/UserManager");
const WebhookManager_1 = require("../managers/global/WebhookManager");
const User_1 = require("./User");
/**
 * The main class for interacting with the api.
 *
 * @template ClientEvents The custom events for the client.
 */
class Client extends node_events_1.EventEmitter {
    /**
     * @param options The options for the client.
     * @throws {Error} Must provide options in client constructor in the form of an object.
     * @throws {Error} No token provided.
     */
    constructor(options) {
        // eslint-disable-next-line constructor-super
        super();
        this.options = options;
        /**
         * The time in milliseconds since the Client connected.
         */
        this.readyTimestamp = null;
        /**
         * The manager for the bot to make requests to the REST api.
         */
        this.rest = new api_1.RestManager(Object.assign(Object.assign({}, this.options.rest), { token: this.options.token }));
        /**
         * The websocket connection.
         */
        this.ws = new api_1.WebSocketManager({ token: this.options.token });
        /**
         * The gateway events will be processed by this manager.
         */
        this.gatewayHandler = new ClientGatewayHandler_1.ClientGatewayHandler(this);
        /**
         * A manager for channels, used to manage and interact with channels.
         */
        this.channels = new ChannelManager_1.GlobalChannelManager(this);
        /**
         * A manager for docs, used to manage and interact with docs.
         */
        this.docs = new DocManager_1.GlobalDocManager(this);
        /**
         * A manager for forum topics, used to manage and interact with forum topics.
         */
        this.topics = new ForumManager_1.GlobalForumTopicManager(this);
        /**
         * A manager for groups, used to manage and interact with groups.
         */
        this.groups = new GroupManager_1.GlobalGroupManager(this);
        /**
         * A manager for list items, used to manage and interact with list items.
         */
        this.lists = new ListManager_1.GlobalListItemManager(this);
        /**
         * A manager for members, used to manage and interact with members.
         */
        this.members = new MemberManager_1.GlobalMemberManager(this);
        /**
         * A manager for messages, used to manage and interact with messages.
         */
        this.messages = new MessageManager_1.GlobalMessageManager(this);
        /**
         * A manager for roles, used to manage and interact with roles.
         */
        this.roles = new RoleManager_1.GlobalRoleManager(this);
        /**
         * A manager for users, used to manage and interact with users.
         */
        this.users = new UserManager_1.GlobalUserManager(this);
        /**
         * A manager for guild bans, used to manage and interact with bans.
         */
        this.bans = new GuildBanManager_1.GlobalGuildBanManager(this);
        /**
         * A manager for webhooks, used to manage and interact with webhooks.
         */
        this.webhooks = new WebhookManager_1.GlobalWebhookManager(this);
        /**
         * A manager for servers, used to manage and interact with servers.
         */
        this.servers = new ServerManager_1.GlobalServerManager(this);
        /**
         * A manager for reactions, used to manage and interact with reactions.
         */
        this.reactions = new ReactionManager_1.GlobalReactionManager(this);
        /**
         * A manager for calendars, used to manage and interact with calendars.
         */
        this.calendars = new CalendarManager_1.GlobalCalendarManager(this);
        /**
         * A manager for categories, used to manage and interact with categories.
         */
        this.categories = new CategoryManager_1.GlobalCategoryManager(this);
        /**
         * A manager for server subscriptions, used to manage and interact with server subscriptions.
         */
        this.subscriptions = new SubscriptionManager_1.GlobalSubscriptionManager(this);
        /**
         * The user belonging to this bot.
         */
        this.user = null;
        if (typeof options !== "object")
            throw new Error("Must provide options in client constructor in the form of an object.");
        if (typeof (options === null || options === void 0 ? void 0 : options.token) === "undefined")
            throw new Error("No token provided.");
    }
    /**
     * The amount of time the bot has been online in milliseconds.
     */
    get uptime() {
        return this.readyTimestamp ? Date.now() - this.readyTimestamp : 0;
    }
    /**
     * The bot's token.
     */
    get token() {
        return this.options.token;
    }
    /**
     * Connects the bot to the api.
     *
     * @param [opts] The options for connecting to the api.
     * @param [opts.fresh] Whether this should create a new WebSocketManager instance.
     * @example
     * let client = new Guilded.Client({ token: process.env.GUILDED_TOKEN });
     * client.on('ready', () => console.log('Logged in!'));
     * client.login();
     */
    login(opts) {
        if (opts === null || opts === void 0 ? void 0 : opts.fresh)
            this.ws = new api_1.WebSocketManager({ token: this.options.token });
        this.ws.emitter
            .on("error", (reason, err) => this.emit("error", `[WS] ${reason}`, err))
            .on("ready", (user) => {
            this.user = new User_1.ClientUser(this, user);
            this.readyTimestamp = Date.now();
            this.emit("ready");
        })
            .on("gatewayEvent", (event, data) => this.gatewayHandler.handleWSMessage(event, data))
            .on("debug", (data) => this.emit("debug", data))
            .on("exit", () => this.emit("exit"));
        this.ws.connect();
    }
    /**
     * Disconnects the bot.
     *
     * @throws {Error} There is no active connection to disconnect.
     */
    disconnect() {
        if (!this.ws.isAlive)
            throw new Error("There is no active connection to disconnect.");
        this.ws.emitter.removeAllListeners();
        this.ws.destroy();
        this.emit("exit");
    }
    /**
     * Fetches the logged in client's servers.
     *
     * @returns The logged in client's servers.
     */
    fetchServers() {
        return this.users.fetchServers(this.user.id);
    }
    /**
     * Set current logged in client's status
     *
     * @param options The options for setting the status.
     * @param options.content The content of the status.
     * @param options.emoteId The id of the emote to use for the status.
     * @param options.expiresAt The time the status should expire.
     */
    setStatus(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let resolvedDate;
            if (options.expiresAt instanceof Date) {
                resolvedDate = options.expiresAt;
            }
            else if (typeof options.expiresAt === "string") {
                resolvedDate = new Date(options.expiresAt);
            }
            else if (typeof options.expiresAt === "number") {
                resolvedDate = new Date(Date.now() + options.expiresAt);
            }
            yield this.rest.router.userStatus.userStatusCreate({
                userId: this.user.id,
                requestBody: {
                    content: options.content,
                    emoteId: options.emoteId,
                    expiresAt: (_a = resolvedDate === null || resolvedDate === void 0 ? void 0 : resolvedDate.toISOString()) !== null && _a !== void 0 ? _a : undefined,
                },
            });
        });
    }
    /**
     * Clear current logged in client's status
     */
    clearStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.rest.router.userStatus.userStatusDelete({
                userId: this.user.id,
            });
        });
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map