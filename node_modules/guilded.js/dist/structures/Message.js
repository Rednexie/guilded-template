"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageReaction = exports.Message = exports.MessageType = void 0;
const util_1 = require("../util");
const Base_1 = require("./Base");
const Embed_1 = require("./Embed");
var MessageType;
(function (MessageType) {
    MessageType[MessageType["Default"] = 0] = "Default";
    MessageType[MessageType["System"] = 1] = "System";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
class Message extends Base_1.Base {
    constructor(client, data) {
        var _a, _b, _c, _d, _e, _f, _g;
        super(client, data);
        /** The ID of the messages that this is replying to. */
        this.replyMessageIds = [];
        /** Whether the message has been deleted */
        this.deleted = false;
        /** When the message was deleted, if it was */
        this._deletedAt = null;
        /** Embeds contained within this message */
        this.embeds = [];
        this.isReply = Boolean(data.replyMessageIds);
        this.channelId = data.channelId;
        this.groupId = (_a = data.groupId) !== null && _a !== void 0 ? _a : null;
        this.content = (_b = data.content) !== null && _b !== void 0 ? _b : "";
        this.serverId = (_c = data.serverId) !== null && _c !== void 0 ? _c : null;
        this.replyMessageIds = (_d = data.replyMessageIds) !== null && _d !== void 0 ? _d : [];
        this.createdById = data.createdBy;
        this.createdByWebhookId = (_e = data.createdByWebhookId) !== null && _e !== void 0 ? _e : null;
        this._createdAt = (0, util_1.parseToStamp)(data.createdAt);
        this._updatedAt = null;
        this.isPrivate = (_f = data.isPrivate) !== null && _f !== void 0 ? _f : false;
        this.isSilent = (_g = data.isSilent) !== null && _g !== void 0 ? _g : false;
        this.type = data.type === "system" ? MessageType.System : MessageType.Default;
        this._update(data);
    }
    /** Update details of this structure */
    _update(data) {
        var _a, _b;
        if ("content" in data && typeof data.content !== "undefined") {
            this.content = data.content;
        }
        if ("mentions" in data) {
            this.mentions = data.mentions;
        }
        if ("updatedAt" in data) {
            this._updatedAt = (0, util_1.parseToStamp)(data.updatedAt);
        }
        if ("deletedAt" in data) {
            this.deleted = true;
            this._deletedAt = (0, util_1.parseToStamp)(data.deletedAt);
        }
        if ("embeds" in data) {
            this.embeds = (_b = (_a = data.embeds) === null || _a === void 0 ? void 0 : _a.map((x) => new Embed_1.Embed(x))) !== null && _b !== void 0 ? _b : [];
        }
        return this;
    }
    get createdAt() {
        return new Date(this._createdAt);
    }
    /**
     * Returns the date and time the message was last updated, if relevant.
     */
    get updatedAt() {
        return this._updatedAt ? new Date(this._updatedAt) : null;
    }
    /**
     * Returns the date and time the message was deleted, if it was.
     */
    get deletedAt() {
        return this._deletedAt ? new Date(this._deletedAt) : null;
    }
    /** Returns the url of this message */
    get url() {
        if (!this.serverId)
            return "";
        return `https://www.guilded.gg/chat/${this.channelId}?messageId=${this.id}`;
    }
    /**
     * Returns the author of this message, or null if the author is not cached.
     */
    get author() {
        var _a;
        return (_a = this.client.users.cache.get(this.createdById)) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Returns the ID of the user who sent this message.
     */
    get authorId() {
        var _a;
        return (_a = this.createdByWebhookId) !== null && _a !== void 0 ? _a : this.createdById;
    }
    /**
     * Returns the member of this message, if the message is in a server, or null otherwise or if the member is not cached.
     */
    get member() {
        var _a;
        return this.serverId ? (_a = this.client.members.cache.get((0, util_1.buildMemberKey)(this.serverId, this.authorId))) !== null && _a !== void 0 ? _a : null : null;
    }
    /**
     * Returns the channel that this message belongs to, or null if the channel is not cached.
     */
    get channel() {
        var _a;
        return (_a = this.client.channels.cache.get(this.channelId)) !== null && _a !== void 0 ? _a : null;
    }
    get server() {
        var _a;
        return this.serverId ? (_a = this.client.servers.cache.get(this.serverId)) !== null && _a !== void 0 ? _a : null : null;
    }
    /**
     * Edit message content.
     *
     * @param newContent - The new content of the message.
     * @returns A promise that resolves with the updated message.
     */
    edit(newContent) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.messages.update(this.channelId, this.id, newContent);
        });
    }
    /**
     * Send a message in the same channel as this message.
     *
     * @param content - The content of the message.
     * @example
     * let replyObj = {
     *  content: 'This is text, supports **markdown**.',
     *  embeds: [{
     *    title: 'This is an embed title!',
     *    description: 'A description may go here'
     *  }]
     * };
     * message.send(replyObj)
     */
    send(content) {
        return this.client.messages.send(this.channelId, content);
    }
    /**
     * Send a message that replies to this message. It mentions the user who sent this message.
     *
     * @param content - The content of the message to send.
     * @example
     * let replyObj = {
     *  content: 'This is text, supports **markdown**.',
     *  embeds: [{
     *    title: 'This is an embed title!',
     *    description: 'A description may go here'
     *  }]
     * };
     * message.reply(replyObj)
     */
    reply(content) {
        return this.client.messages.send(this.channelId, Object.assign(Object.assign({}, (0, util_1.resolveContentToData)(content)), { replyMessageIds: [this.id] }));
    }
    createThread(name) {
        return this.client.channels.create({
            name,
            messageId: this.id,
            type: "chat",
        });
    }
    awaitReactions(options) {
        return this.client.reactions.awaitReactions(this.id, options);
    }
    /**
     * Add a reaction emote.
     *
     * @param emoteId - The ID of the emote to add.
     * @returns A promise that resolves when the emote has been added.
     */
    addReaction(emoteId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.rest.router.reactions.channelMessageReactionCreate({
                channelId: this.channelId,
                messageId: this.id,
                emoteId,
            });
        });
    }
    /**
     * Deletes either a whole reaction emote from a message or a specific user's if a userId is provided.
     *
     * @param emoteId - The ID of the emote to delete.
     * @returns A promise that resolves when the emote has been deleted.
     */
    deleteReaction(emoteId, userId) {
        return this.client.rest.router.reactions.channelMessageReactionDelete({
            channelId: this.channelId,
            messageId: this.id,
            emoteId,
            userId,
        });
    }
    /**
     * Delete this message.
     *
     * @returns A promise that resolves when the message has been deleted.
     */
    delete() {
        return this.client.messages.delete(this.channelId, this.id);
    }
}
exports.Message = Message;
/**
 * Represents a reaction to a message.
 */
class MessageReaction extends Base_1.Base {
    /**
     * Creates a new instance of the MessageReaction class.
     *
     * @param client The client that instantiated this object.
     * @param data The data representing the reaction.
     */
    constructor(client, data) {
        const formedId = (0, util_1.buildReactionKey)(data.createdBy, data.emote.id);
        super(client, Object.assign(Object.assign({}, data), { id: formedId }));
        this.id = formedId;
        this.channelId = data.channelId;
        this.messageId = data.messageId;
        this.createdBy = data.createdBy;
        this.emote = data.emote;
        this.serverId = data.serverId;
    }
}
exports.MessageReaction = MessageReaction;
//# sourceMappingURL=Message.js.map