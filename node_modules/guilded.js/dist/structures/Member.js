"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemberBan = exports.PartialMember = exports.Member = void 0;
const collection_1 = require("@discordjs/collection");
const util_1 = require("../util");
const Base_1 = require("./Base");
class Member extends Base_1.Base {
    constructor(client, data) {
        super(client, data);
        /** The nickname for this member */
        this.nickname = null;
        /** Roles this member has by ID (TODO: role object when Guilded API has one) */
        this.roleIds = [];
        this.serverId = data.serverId;
        this._joinedAt = (0, util_1.parseToStamp)(data.joinedAt);
        this.kicked = false;
        this.banned = false;
        this.isOwner = false;
        this.socialLinks = new collection_1.Collection();
        this._update(data);
    }
    get joinedAt() {
        return this._joinedAt ? new Date(this._joinedAt) : null;
    }
    _update(data) {
        var _a;
        if ("nickname" in data) {
            this.nickname = (_a = data.nickname) !== null && _a !== void 0 ? _a : null;
        }
        if ("roleIds" in data && typeof data.roleIds !== "undefined") {
            this.roleIds = data.roleIds;
        }
        if ("kicked" in data && typeof data.kicked !== "undefined") {
            this.kicked = data.kicked;
        }
        if ("banned" in data && typeof data.banned !== "undefined") {
            this.banned = data.banned;
        }
        if ("isOwner" in data && typeof data.isOwner !== "undefined") {
            this.isOwner = data.isOwner;
        }
        return this;
    }
    /**
     * Get the user associated with this member.
     *
     * @returns The user associated with this member or null if the user is not cached.
     */
    get user() {
        var _a;
        return (_a = this.client.users.cache.get(this.id)) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * The username of this member.
     *
     * @returns The username of this member or null if the user is not cached.
     */
    get username() {
        var _a, _b;
        return (_b = (_a = this.user) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * Either the nickname or the username associated with this member.
     *
     * @returns The nickname of this member or their username if they have no nickname, or null if the user does not exist.
     */
    get displayName() {
        var _a;
        return (_a = this.nickname) !== null && _a !== void 0 ? _a : this.username;
    }
    /**
     * Get a list of the roles assigned to this member.
     *
     * @returns A Promise that resolves with an array of role IDs assigned to this member.
     */
    getRoles() {
        return this.client.members.getRoles(this.serverId, this.id);
    }
    /**
     * Update this member's nickname.
     *
     * @param nickname - The new nickname for the member.
     * @returns A Promise that resolves with the new nickname for the member.
     */
    updateNickname(nickname) {
        return this.client.members.updateNickname(this.serverId, this.id, nickname);
    }
    /**
     * Reset this member's nickname.
     *
     * @returns A Promise that resolves once the member's nickname has been reset.
     */
    resetNickname() {
        return this.client.members.resetNickname(this.serverId, this.id);
    }
    /**
     * Award XP to this member.
     *
     * @param amount - The amount of XP to award to the member.
     * @returns A Promise that resolves with the new total amount of XP the member has.
     */
    awardXP(amount) {
        return this.client.members.giveXP(this.serverId, this.id, amount);
    }
    /**
     * Add role to this member.
     *
     * @param roleId - The ID of the role to add to the member.
     * @returns A Promise that resolves once the role has been added to the member.
     */
    addRole(roleId) {
        return this.client.roles.addRoleToMember(this.serverId, this.id, roleId);
    }
    /**
     * Remove role from this member.
     *
     * @param roleId - The ID of the role to remove from the member.
     * @returns A Promise that resolves once the role has been removed from the member.
     */
    removeRole(roleId) {
        return this.client.roles.removeRoleFromMember(this.serverId, this.id, roleId);
    }
    /**
     * Kick this user from the server.
     *
     * @returns A Promise that resolves with the kicked member or null if the user is not a member of the server.
     */
    kick() {
        return this.client.members.kick(this.serverId, this.id);
    }
    /**
     * Ban this user
     *
     * @returns A Promise that resolved to the created member ban.
     */
    ban() {
        return this.client.bans.ban(this.serverId, this.id);
    }
}
exports.Member = Member;
/** A partial summary representation of a member. Can fetch this member to get full data */
class PartialMember extends Base_1.Base {
    constructor(client, data) {
        super(client, data);
        /** Roles this member has by ID (TODO: role object when Guilded API has one) */
        this.roleIds = [];
        this.serverId = data.serverId;
        this.user = data.user;
        this.roleIds = data.roleIds;
    }
    /**
     * Fetch the full member object of this partial member
     *
     * @returns A promise containing the resolved full member.
     */
    fetch() {
        return this.client.members.fetch(this.serverId, this.user.id);
    }
}
exports.PartialMember = PartialMember;
/**
 * Represents a banned member.
 */
class MemberBan extends Base_1.Base {
    /**
     * Creates a new instance of `MemberBan`.
     *
     * @param client - The Guilded client instance.
     * @param data - The data for this member ban.
     */
    constructor(client, data) {
        var _a;
        const transformedBanId = (0, util_1.buildMemberKey)(data.serverId, data.user.id);
        super(client, Object.assign(Object.assign({}, data), { id: transformedBanId }));
        this.serverId = data.serverId;
        this._createdAt = (0, util_1.parseToStamp)(data.createdAt);
        this.createdById = data.createdBy;
        this.target = data.user;
        this.reason = (_a = data.reason) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Gets the creation date of this ban.
     *
     * @returns The creation date of this ban.
     */
    get createdAt() {
        return new Date(this._createdAt);
    }
    /**
     * Gets the user who banned this member.
     *
     * @returns The user who banned this member, or `null` if the user is not cached.
     */
    get author() {
        var _a;
        return (_a = this.client.users.cache.get(this.createdById)) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Removes this ban.
     *
     * @returns A Promise that resolves to the unbanned member or `null` if the member is not cached.
     */
    unban() {
        return this.client.bans.unban(this.serverId, this.target.id);
    }
}
exports.MemberBan = MemberBan;
//# sourceMappingURL=Member.js.map