"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerMemberEventHandler = void 0;
const constants_1 = require("../../constants");
const structures_1 = require("../../structures");
const util_1 = require("../../util");
const GatewayEventHandler_1 = require("./GatewayEventHandler");
class ServerMemberEventHandler extends GatewayEventHandler_1.GatewayEventHandler {
    serverMemberUpdated(data) {
        var _a;
        const { d: { userInfo: { id, nickname }, serverId, }, } = data;
        const member = this.client.members.cache.get((0, util_1.buildMemberKey)(serverId, id));
        const oldMember = member === null || member === void 0 ? void 0 : member._clone();
        member === null || member === void 0 ? void 0 : member._update({ nickname: (_a = data.d.userInfo.nickname) !== null && _a !== void 0 ? _a : undefined });
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_UPDATED, {
            serverId,
            userId: id,
            nickname: nickname !== null && nickname !== void 0 ? nickname : null,
            oldMember: oldMember !== null && oldMember !== void 0 ? oldMember : null,
        });
    }
    serverMemberJoined(data) {
        const newMember = new structures_1.Member(this.client, Object.assign(Object.assign({}, data.d.member), { serverId: data.d.serverId, id: data.d.member.user.id }));
        const newUser = new structures_1.User(this.client, data.d.member.user);
        this.client.members.cache.set((0, util_1.buildMemberKey)(data.d.serverId, data.d.member.user.id), newMember);
        this.client.users.cache.set(newUser.id, newUser);
        if (data.d.member.user.id === this.client.user.id)
            this.client.emit(constants_1.constants.clientEvents.SERVER_CREATED, {
                serverId: data.d.serverId,
            });
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_JOINED, newMember);
    }
    serverMemberRemoved(data) {
        var _a;
        const memberKey = (0, util_1.buildMemberKey)(data.d.serverId, data.d.userId);
        const existingMember = this.client.members.cache.get(memberKey);
        if ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.removeMemberOnLeave)
            this.client.members.cache.delete(memberKey);
        existingMember === null || existingMember === void 0 ? void 0 : existingMember._update({
            kicked: data.d.isKick,
            banned: data.d.isBan,
        });
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_REMOVED, data.d);
    }
    serverMemberBanned(data) {
        var _a;
        const newMemberBan = new structures_1.MemberBan(this.client, Object.assign({ serverId: data.d.serverId }, data.d.serverMemberBan));
        if (((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheMemberBans) !== false)
            this.client.bans.cache.set((0, util_1.buildMemberKey)(newMemberBan.serverId, newMemberBan.target.id), newMemberBan);
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_BANNED, newMemberBan);
    }
    serverMemberUnbanned(data) {
        var _a;
        const { d: { serverId, serverMemberBan: { createdAt, createdBy, reason, user }, }, } = data;
        const memberKey = (0, util_1.buildMemberKey)(serverId, user.id);
        const existingMemberBan = this.client.bans.cache.get(memberKey);
        if (existingMemberBan && ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.removeMemberBanOnUnban))
            this.client.bans.cache.delete(existingMemberBan.id);
        const existingMember = this.client.members.cache.get(memberKey);
        if (existingMember)
            existingMember._update({ banned: false });
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_UNBANNED, {
            createdAt,
            createdBy,
            reason,
            user,
            serverId,
        });
    }
    serverMemberSocialLinkCreated(data) {
        const { d: { serverId, socialLink }, } = data;
        const existingMember = this.client.members.cache.get((0, util_1.buildMemberKey)(serverId, socialLink.userId));
        if (this.client.members.shouldCacheSocialLinks)
            existingMember === null || existingMember === void 0 ? void 0 : existingMember.socialLinks.set(socialLink.type, socialLink);
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_SOCIAL_LINK_CREATED, serverId, socialLink);
    }
    serverMemberSocialLinkUpdated(data) {
        const { d: { serverId, socialLink }, } = data;
        const existingMember = this.client.members.cache.get((0, util_1.buildMemberKey)(serverId, socialLink.userId));
        if (this.client.members.shouldCacheSocialLinks)
            existingMember === null || existingMember === void 0 ? void 0 : existingMember.socialLinks.set(socialLink.type, socialLink);
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_SOCIAL_LINK_UPDATED, serverId, socialLink);
    }
    serverMemberSocialLinkDeleted(data) {
        const { d: { serverId, socialLink }, } = data;
        const existingMember = this.client.members.cache.get((0, util_1.buildMemberKey)(serverId, socialLink.userId));
        if (this.client.members.shouldCacheSocialLinks)
            existingMember === null || existingMember === void 0 ? void 0 : existingMember.socialLinks.delete(socialLink.type);
        return this.client.emit(constants_1.constants.clientEvents.MEMBER_SOCIAL_LINK_DELETED, serverId, socialLink);
    }
}
exports.ServerMemberEventHandler = ServerMemberEventHandler;
//# sourceMappingURL=ServerMemberEventHandler.js.map